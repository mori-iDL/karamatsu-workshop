<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ£®ãŒè‚²ã‚€ã€ã„ã®ã¡ã®å¾ªç’° â€” ã„ã‚ã¯ã™ãŒç”Ÿã¾ã‚Œã‚‹å²©æ‰‹ã®æ£®ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ‡ã‚¶ã‚¤ãƒ³</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Hiragino Mincho ProN', 'Yu Mincho', serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #f8f9fa;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 32px;
            font-weight: 400;
            letter-spacing: 0.1em;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 15px;
            letter-spacing: 0.05em;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .cell {
            aspect-ratio: 1;
            border: 3px solid #34495e;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .cell:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .cell-label {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #95a5a6;
            font-weight: 500;
            letter-spacing: 0.05em;
        }
        
        .cell canvas {
            width: 90%;
            height: 90%;
        }
        
        .controls {
            background: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid #34495e;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 15px;
            color: #2c3e50;
            font-weight: 500;
        }
        
        .control-value {
            color: #e74c3c;
            font-weight: 700;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ecf0f1;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #e74c3c;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #e74c3c;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            border: none;
        }
        
        .story {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        /* === æ–°æ©Ÿèƒ½: ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ»ãƒ©ãƒ³ãƒ€ãƒ ãƒœã‚¿ãƒ³ === */
        .preset-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            padding: 12px 20px;
            border: 2px solid #34495e;
            border-radius: 25px;
            background: white;
            color: #34495e;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 100px;
        }
        
        .preset-btn:hover {
            background: #34495e;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 73, 94, 0.3);
        }
        
        .preset-btn.active {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
        }
        
        .random-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            border-color: #8e44ad;
            color: white;
        }
        
        .random-btn:hover {
            background: linear-gradient(135deg, #8e44ad 0%, #7d3c98 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(142, 68, 173, 0.4);
        }
        
        /* === æ–°æ©Ÿèƒ½: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¬æ˜ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— === */
        .param-help {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #bdc3c7;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.3s;
        }
        
        .param-help:hover {
            background: #3498db;
            transform: scale(1.1);
        }
        
        .tooltip {
            display: none;
            position: absolute;
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.6;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            left: 50%;
            transform: translateX(-50%);
            top: 100%;
            margin-top: 10px;
        }
        
        .tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px 8px;
            border-style: solid;
            border-color: transparent transparent #2c3e50 transparent;
        }
        
        .tooltip.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* === æ–°æ©Ÿèƒ½: é¸æŠä¸­ã‚¹ãƒ†ãƒ¼ã‚¸ã®å¼·èª¿è¡¨ç¤º === */
        .cell.selected {
            border: 4px solid #e74c3c;
            box-shadow: 0 0 0 4px rgba(231, 76, 60, 0.3), 0 8px 25px rgba(231, 76, 60, 0.4);
            transform: scale(1.02);
        }
        
        .cell.selected .cell-label {
            color: #e74c3c;
            font-weight: 700;
        }
        
        .cell.selected::after {
            content: 'âœ“ é¸æŠä¸­';
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: #e74c3c;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        /* === æ–°æ©Ÿèƒ½: ã‚¹ãƒãƒ›å‘ã‘ã‚¿ãƒƒãƒæœ€é©åŒ– === */
        @media (max-width: 768px) {
            input[type="range"] {
                height: 12px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 28px;
                height: 28px;
            }
            
            .control-group {
                padding: 5px 0;
            }
            
            .preset-btn {
                padding: 10px 8px;
                font-size: 11px;
                min-width: auto;
                flex: 1;
            }
            
            .preset-buttons {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
                margin-bottom: 10px;
            }
            
            .preset-btn {
                padding: 8px 4px;
                font-size: 10px;
                min-width: auto;
                white-space: nowrap;
            }
            
            .random-btn {
                grid-column: 1 / -1;
                padding: 10px;
                font-size: 12px;
            }
            
            .param-help {
                width: 20px;
                height: 20px;
                line-height: 20px;
                font-size: 11px;
                margin-left: 4px;
            }
            
            .tooltip {
                font-size: 11px;
                padding: 10px;
                max-width: 250px;
            }
            
            .compare-section {
                padding: 12px;
                margin-top: 10px;
            }
            
            .compare-section h4 {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .compare-box canvas {
                width: 100px;
                height: 100px;
            }
            
            .compare-arrow {
                font-size: 20px;
            }
        }
        
        /* === æ–°æ©Ÿèƒ½: ãƒ“ãƒ•ã‚©ãƒ¼ã‚¢ãƒ•ã‚¿ãƒ¼æ¯”è¼ƒ === */
        .compare-section {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            text-align: center;
        }
        
        .compare-section h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .compare-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .compare-box {
            text-align: center;
        }
        
        .compare-box canvas {
            border: 2px solid #34495e;
            border-radius: 8px;
            background: white;
        }
        
        .compare-box p {
            margin-top: 8px;
            font-size: 13px;
            color: #7f8c8d;
            font-weight: 600;
        }
        
        .compare-arrow {
            font-size: 30px;
            color: #e74c3c;
        }
        
        .compare-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .compare-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .compare-btn.save {
            background: #3498db;
            color: white;
        }
        
        .compare-btn.reset {
            background: #95a5a6;
            color: white;
        }
        
        .story h2 {
            font-size: 20px;
            margin-bottom: 15px;
            font-weight: 400;
            letter-spacing: 0.1em;
        }
        
        .story p {
            font-size: 15px;
            line-height: 1.8;
            opacity: 0.95;
            letter-spacing: 0.05em;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        button {
            padding: 18px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.05em;
        }
        
        .btn-generate {
            background: #27ae60;
            color: white;
        }
        
        .btn-generate:hover {
            background: #229954;
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(39, 174, 96, 0.4);
        }
        
        .btn-save {
            background: #3498db;
            color: white;
        }
        
        .btn-save:hover {
            background: #2980b9;
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
        }
        
        .btn-download {
            background: #e74c3c;
            color: white;
        }
        
        .btn-download:hover {
            background: #c0392b;
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);
        }
        
        /* SVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨è¿½åŠ ã‚¹ã‚¿ã‚¤ãƒ« */
        .download-section {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin-top: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        .download-section h3 {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: 400;
            letter-spacing: 0.1em;
        }
        
        .download-section p {
            font-size: 14px;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .selected-stage-info {
            background: rgba(255,255,255,0.15);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .selected-stage-info h4 {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .param-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 13px;
            margin-top: 10px;
        }
        
        .param-item {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 5px;
        }
        
        .btn-svg-download {
            background: #f39c12;
            color: white;
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        
        .btn-svg-download:hover {
            background: #e67e22;
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.5);
        }
        
        .btn-svg-download:active {
            transform: translateY(-1px);
        }
        
        /* ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                margin: 0;
            }
            
            .container {
                padding: 10px;
                max-width: 100vw;
            }
            
            h1 {
                font-size: 20px;
                margin-bottom: 5px;
            }
            
            .subtitle {
                font-size: 12px;
                margin-bottom: 10px;
            }
            
            .story {
                margin-bottom: 15px;
            }
            
            .story h2 {
                font-size: 16px;
            }
            
            .story p {
                font-size: 12px;
                line-height: 1.4;
            }
            
            .controls {
                position: sticky;
                top: 0;
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                z-index: 100;
                padding: 10px;
                margin: -10px -10px 10px -10px;
                border-bottom: 2px solid #28a745;
                box-shadow: 0 2px 6px rgba(0,0,0,0.1);
                border-radius: 0 0 10px 10px;
            }
            
            .controls::before {
                display: none;
            }
            
            .control-group {
                margin-bottom: 12px;
            }
            
            .control-label {
                font-size: 13px;
                margin-bottom: 5px;
            }
            
            .control-label span:first-child {
                font-size: 12px;
            }
            
            .control-label .control-value {
                font-size: 14px;
                font-weight: bold;
            }
            
            input[type="range"] {
                width: 100%;
                height: 8px;
            }
            
            .stage-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
                margin-bottom: 15px;
                padding: 10px;
                background: rgba(248, 249, 250, 0.8);
                border-radius: 8px;
                border: 1px solid #dee2e6;
            }
            
            .stage-item {
                padding: 6px 3px;
                font-size: 9px;
                min-height: 50px;
                text-align: center;
                line-height: 1.1;
                border-radius: 6px;
                transition: all 0.2s ease;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
            }
            
            .stage-item:hover {
                background: #f0f8ff;
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            
            .stage-item.selected {
                background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
                border: 2px solid #28a745;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
                font-weight: bold;
            }
            
            .canvas-container {
                margin: 15px 0;
                text-align: center;
                position: relative;
                min-height: 300px;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 10px;
            }
            
            canvas {
                width: 280px;
                height: 280px;
                border: 2px solid #dee2e6;
                border-radius: 8px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            }
            
            /* ã‚ˆã‚Šå°ã•ãªã‚¹ãƒãƒ›å¯¾å¿œ */
            @media (max-width: 480px) {
                canvas {
                    width: 250px;
                    height: 250px;
                }
            }
            
            @media (max-width: 360px) {
                canvas {
                    width: 220px;
                    height: 220px;
                }
            }
            
            .grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .param-display {
                flex-direction: column;
                gap: 8px;
            }
            
            .download-section {
                padding: 15px;
                margin-top: 20px;
            }
            
            .download-section h3 {
                font-size: 16px;
            }
            
            .download-section p {
                font-size: 13px;
            }
            
            .btn-svg-download {
                font-size: 14px;
                padding: 12px 20px;
                width: 100%;
            }
        }
    </style>
    
    <!-- canvas2svg ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼SVGç”Ÿæˆç”¨ï¼‰ - ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ« -->
    <script src="./canvas2svg.js"></script>
</head>
<body>
    <div class="container">
        <h1>æ£®ãŒè‚²ã‚€ã€ã„ã®ã¡ã®å¾ªç’°</h1>
        <p class="subtitle">ã„ã‚ã¯ã™ãŒç”Ÿã¾ã‚Œã‚‹å²©æ‰‹ã®æ£®ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ‡ã‚¶ã‚¤ãƒ³</p>
        
        <div class="story">
            <h2>é›ªæ·±ã„ç››å²¡ã§è‚²ã¤ã€å”æ¾ã®è¨˜æ†¶</h2>
            <p>ç¨®ãŒé›ªã«åŒ…ã¾ã‚ŒãŸå†¬ã‹ã‚‰å§‹ã¾ã‚Šã€èŠ½å¹ãã€æˆé•·ã—ã€æœ¨æã¨ãªã‚Šã€è·äººã®æ‰‹ã§åŠ å·¥ã•ã‚Œã€ãã—ã¦ç«¯æã¨ãªã£ã¦ã‚‚è¨˜æ†¶ã‚’æŒã¡ç¶šã‘ã‚‹ã€‚
            <br>ã‚ãªãŸã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã€ã“ã®æœ¨ã®ä¸€ç”Ÿã«æ¯ã‚’å¹ãè¾¼ã¿ã¾ã™ã€‚
            <br>9ã¤ã®ã‚­ãƒ¥ãƒ¼ãƒ–ãŒèªã‚‹ã€çµ‚ã‚ã‚Šãªãå¾ªç’°ã®ç‰©èªã€‚</p>
        </div>
        
        <div class="controls">
            <!-- ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ»ãƒ©ãƒ³ãƒ€ãƒ ãƒœã‚¿ãƒ³ -->
            <div class="preset-buttons">
                <button class="preset-btn" onclick="applyPreset('soft')" id="preset-soft">ğŸŒ± ã‚„ã‚ã‚‰ã‹ã„</button>
                <button class="preset-btn" onclick="applyPreset('dynamic')" id="preset-dynamic">âš¡ ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯</button>
                <button class="preset-btn" onclick="applyPreset('balance')" id="preset-balance">ğŸ¨ ãƒãƒ©ãƒ³ã‚¹</button>
                <button class="preset-btn random-btn" onclick="applyRandom()">ğŸ² ãƒ©ãƒ³ãƒ€ãƒ </button>
            </div>
            
            <div class="control-group" style="position: relative;">
                <div class="control-label">
                    <span>æˆé•·ã®åŠ›å¼·ã• (é¢¨é›ªã«è€ãˆã‚‹å¼·ã•)<span class="param-help" onclick="toggleTooltip('growth-tooltip')">?</span></span>
                    <span class="control-value" id="growth-value">70%</span>
                </div>
                <div class="tooltip" id="growth-tooltip">
                    <strong>ğŸŒ² æˆé•·ã®åŠ›å¼·ã•ã¨ã¯ï¼Ÿ</strong><br>
                    æœ¨ã®æˆé•·åº¦åˆã„ã‚’å¤‰ãˆã¾ã™ã€‚è¤‡é›‘ã•ã€å¯†åº¦ã€ã‚µã‚¤ã‚ºã«å½±éŸ¿ã€‚<br>
                    <em>â†’ã€Œè‹¥ã€…ã—ã„æœ¨ã€ã¨ã€Œè€æœ¨ã€ã€ã©ã¡ã‚‰ã®ç‰©èªã‚’æãã¾ã™ã‹ï¼Ÿ</em>
                </div>
                <input type="range" id="growth-power" min="0" max="100" value="70">
            </div>
            
            <div class="control-group" style="position: relative;">
                <div class="control-label">
                    <span>æœ‰æ©Ÿæ€§ (è‡ªç„¶ã®ä¸å®Œå…¨æ€§)<span class="param-help" onclick="toggleTooltip('organic-tooltip')">?</span></span>
                    <span class="control-value" id="organic-value">60%</span>
                </div>
                <div class="tooltip" id="organic-tooltip">
                    <strong>ğŸŒŠ æœ‰æ©Ÿæ€§ã¨ã¯ï¼Ÿ</strong><br>
                    æºã‚‰ãã‚„ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¹ã®åº¦åˆã„ã‚’å¤‰ãˆã¾ã™ã€‚ä½ã„ã¨æ•´ç„¶ã€é«˜ã„ã¨é‡æ€§çš„ã«ã€‚<br>
                    <em>â†’ã€Œæ•´ç„¶ã¨ã—ãŸæ£®ã€ã¨ã€Œé‡æ€§çš„ãªæ£®ã€ã€ã©ã¡ã‚‰ã‚’æƒ³åƒã—ã¾ã™ã‹ï¼Ÿ</em>
                </div>
                <input type="range" id="organic-nature" min="0" max="100" value="60">
            </div>
            
            <div class="control-group" style="position: relative;">
                <div class="control-label">
                    <span>æ™‚é–“ã®æµã‚Œ (éå» â† â†’ æœªæ¥)<span class="param-help" onclick="toggleTooltip('time-tooltip')">?</span></span>
                    <span class="control-value" id="time-value">0</span>
                </div>
                <div class="tooltip" id="time-tooltip">
                    <strong>â³ æ™‚é–“ã®æµã‚Œã¨ã¯ï¼Ÿ</strong><br>
                    éå»ãƒ»ç¾åœ¨ãƒ»æœªæ¥ã®ã©ã®æ™‚ç‚¹ã‚’å¼·èª¿ã™ã‚‹ã‹ã‚’å¤‰ãˆã¾ã™ã€‚<br>
                    <em>â†’ã€Œç¨®å­ã®è¨˜æ†¶ã€ã€Œä»Šã®æˆé•·ã€ã€Œæœªæ¥ã¸ã®æ—…ç«‹ã¡ã€ã€ã©ã“ã«ç„¦ç‚¹ã‚’å½“ã¦ã¾ã™ã‹ï¼Ÿ</em>
                </div>
                <input type="range" id="time-flow" min="-100" max="100" value="0">
            </div>
            
            <!-- ãƒ“ãƒ•ã‚©ãƒ¼ã‚¢ãƒ•ã‚¿ãƒ¼æ¯”è¼ƒã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="compare-section" id="compare-section" style="display: none;">
                <h4>ğŸ“Š ãƒ“ãƒ•ã‚©ãƒ¼ã‚¢ãƒ•ã‚¿ãƒ¼æ¯”è¼ƒ</h4>
                <div class="compare-container">
                    <div class="compare-box">
                        <canvas id="compare-before" width="150" height="150"></canvas>
                        <p>å¤‰æ›´å‰</p>
                    </div>
                    <span class="compare-arrow">â†’</span>
                    <div class="compare-box">
                        <canvas id="compare-after" width="150" height="150"></canvas>
                        <p>å¤‰æ›´å¾Œ</p>
                    </div>
                </div>
                <div class="compare-buttons">
                    <button class="compare-btn save" onclick="saveCurrentState()">ğŸ’¾ ã“ã®çŠ¶æ…‹ã‚’è¨˜éŒ²</button>
                    <button class="compare-btn reset" onclick="hideCompare()">âœ• é–‰ã˜ã‚‹</button>
                </div>
            </div>
        </div>
        
        <div class="grid" id="pattern-grid">
            <div class="cell">
                <span class="cell-label">1. ç¨® - é›ªã«çœ ã‚‹</span>
                <canvas id="canvas-1"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">2. èŠ½ - å…‰ã¸çªç ´</span>
                <canvas id="canvas-2"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">3. è‹¥æœ¨ - é¢¨ã«æºã‚Œã‚‹</span>
                <canvas id="canvas-3"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">4. æˆé•· - å¹´è¼ªã®è¨˜æ†¶</span>
                <canvas id="canvas-4"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">5. æœ¨æ - ä¼æ¡ã®ç¬é–“</span>
                <canvas id="canvas-5"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">6. åŠ å·¥ - ãƒ‡ã‚¸ã‚¿ãƒ«ã¨æ‰‹</span>
                <canvas id="canvas-6"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">7. ç«¯æ - æ®‹ã•ã‚ŒãŸè¨˜æ†¶</span>
                <canvas id="canvas-7"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">8. å†ç”Ÿ - é›†ã†æ–­ç‰‡</span>
                <canvas id="canvas-8"></canvas>
            </div>
            <div class="cell">
                <span class="cell-label">9. æœªæ¥ - ç„¡é™ã®å¾ªç’°</span>
                <canvas id="canvas-9"></canvas>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn-generate" onclick="regenerateAll()">ğŸ”„ å†ç”Ÿæˆ</button>
            <button class="btn-download" onclick="downloadImage()">ğŸ“¸ å…¨ä½“ç”»åƒ</button>
            <button class="btn-card" onclick="downloadCardImage()" style="background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);">ğŸ´ ã‚«ãƒ¼ãƒ‰ä¿å­˜</button>
        </div>
        
        <!-- æ¾æ£®ã•ã‚“ç”¨å®Œå…¨ç‰ˆï¼ˆSVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ä»˜ãï¼‰ -->
        <div class="download-section">
            <h3>ğŸ¯ ãƒ¬ãƒ¼ã‚¶ãƒ¼åŠ å·¥ç”¨ãƒ‡ãƒ¼ã‚¿ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h3>
            <p>æ°—ã«å…¥ã£ãŸå›³æŸ„ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠã—ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã—ãŸã‚‰ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã§SVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</p>
            
            <div class="selected-stage-info" id="selected-info">
                <h4>é¸æŠä¸­ï¼š<span id="selected-stage-name">ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é¸æŠã—ã¦ãã ã•ã„</span></h4>
                <div class="param-display">
                    <div class="param-item">æˆé•·ã®åŠ›å¼·ã•: <span id="param-gp-display">70</span></div>
                    <div class="param-item">æœ‰æ©Ÿçš„ãªè‡ªç„¶æ€§: <span id="param-on-display">60</span></div>
                    <div class="param-item">æ™‚é–“ã®æµã‚Œ: <span id="param-tf-display">0</span></div>
                </div>
            </div>
            
            <button class="btn-svg-download" onclick="downloadSVG()" id="svg-download-btn">
                ğŸ“¥ SVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆ39mmÃ—39mmï¼‰
            </button>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.3);">
                <p style="font-size: 16px; margin-bottom: 15px; font-weight: 600;">ğŸ“ ãƒ‡ã‚¶ã‚¤ãƒ³æå‡ºã¯ã“ã¡ã‚‰ã‹ã‚‰</p>
                <button class="btn-svg-download" onclick="openGoogleForms()" style="background: #27ae60;">
                    ğŸ“‹ Google Formsã‚’é–‹ã
                </button>
                
                <!-- QRã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.95); border-radius: 10px; text-align: center;">
                    <p style="color: #2c3e50; font-size: 14px; margin-bottom: 10px; font-weight: 600;">ã¾ãŸã¯ã€ã‚¹ãƒãƒ›ã§ã“ã®QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³</p>
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://forms.gle/VoKPj8Gxz8Qa9B4i6" 
                         alt="Google Forms QRã‚³ãƒ¼ãƒ‰" 
                         style="width: 150px; height: 150px; border: 2px solid #2c3e50; border-radius: 8px;">
                    <p style="color: #7f8c8d; font-size: 12px; margin-top: 10px;">Google Forms æå‡ºç”¨</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let growthPower = 70;
        let organicNature = 60;
        let timeFlow = 0;
        let noiseOffset = Math.random() * 10000;
        
        // é¸æŠã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ç®¡ç†
        let selectedStage = null;
        
        // ========================================
        // ã‚·ãƒ¼ãƒ‰ä»˜ãç–‘ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ï¼ˆMulberry32ï¼‰
        // Canvasè¡¨ç¤ºã¨SVGç”Ÿæˆã§åŒã˜ä¹±æ•°åˆ—ã‚’å†ç¾ã™ã‚‹ãŸã‚
        // ========================================
        let currentSeed = 12345;
        let randomState = currentSeed;
        
        function setSeed(seed) {
            randomState = seed;
        }
        
        function seededRandom() {
            randomState |= 0;
            randomState = randomState + 0x6D2B79F5 | 0;
            let t = Math.imul(randomState ^ randomState >>> 15, 1 | randomState);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
        
        // æç”»é–‹å§‹æ™‚ã«ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã®é–¢æ•°
        function resetRandomForStage(stageNumber) {
            // ã‚¹ãƒ†ãƒ¼ã‚¸ç•ªå·ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚·ãƒ¼ãƒ‰ã‚’ç”Ÿæˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœï¼‰
            const seed = stageNumber * 10000 + growthPower * 100 + organicNature + Math.floor(timeFlow + 100);
            setSeed(seed);
        }
        
        // ãƒ“ãƒ•ã‚©ãƒ¼ã‚¢ãƒ•ã‚¿ãƒ¼æ¯”è¼ƒç”¨ã®çŠ¶æ…‹ä¿å­˜
        let savedState = null;
        
        // ========================================
        // ãƒ—ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
        // ========================================
        const presets = {
            soft: { growth: 40, organic: 30, time: -30, name: 'ã‚„ã‚ã‚‰ã‹ã„' },
            dynamic: { growth: 90, organic: 80, time: 50, name: 'ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯' },
            balance: { growth: 70, organic: 60, time: 0, name: 'ãƒãƒ©ãƒ³ã‚¹' }
        };
        
        function applyPreset(presetName) {
            const preset = presets[presetName];
            if (!preset) return;
            
            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜ï¼ˆæ¯”è¼ƒç”¨ï¼‰
            saveForCompare();
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆå€¤ã‚’é©ç”¨
            growthPower = preset.growth;
            organicNature = preset.organic;
            timeFlow = preset.time;
            
            // UIã‚’æ›´æ–°
            document.getElementById('growth-power').value = growthPower;
            document.getElementById('organic-nature').value = organicNature;
            document.getElementById('time-flow').value = timeFlow;
            
            document.getElementById('growth-value').textContent = growthPower + '%';
            document.getElementById('organic-value').textContent = organicNature + '%';
            document.getElementById('time-value').textContent = timeFlow;
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('preset-' + presetName)?.classList.add('active');
            
            // å†æç”»
            generateAllPatterns();
            updateParamDisplay();
            
            // æ¯”è¼ƒã‚’è¡¨ç¤º
            showCompare();
        }
        
        // ========================================
        // ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆæ©Ÿèƒ½
        // ========================================
        function applyRandom() {
            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜ï¼ˆæ¯”è¼ƒç”¨ï¼‰
            saveForCompare();
            
            // ãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’ç”Ÿæˆ
            growthPower = Math.floor(Math.random() * 100);
            organicNature = Math.floor(Math.random() * 100);
            timeFlow = Math.floor(Math.random() * 201) - 100; // -100 to 100
            
            // UIã‚’æ›´æ–°
            document.getElementById('growth-power').value = growthPower;
            document.getElementById('organic-nature').value = organicNature;
            document.getElementById('time-flow').value = timeFlow;
            
            document.getElementById('growth-value').textContent = growthPower + '%';
            document.getElementById('organic-value').textContent = organicNature + '%';
            document.getElementById('time-value').textContent = timeFlow;
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            
            // å†æç”»
            generateAllPatterns();
            updateParamDisplay();
            
            // æ¯”è¼ƒã‚’è¡¨ç¤º
            showCompare();
        }
        
        // ========================================
        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—æ©Ÿèƒ½
        // ========================================
        function toggleTooltip(tooltipId) {
            const tooltip = document.getElementById(tooltipId);
            const isShowing = tooltip.classList.contains('show');
            
            // å…¨ã¦ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
            document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('show'));
            
            // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’ãƒˆã‚°ãƒ«
            if (!isShowing) {
                tooltip.classList.add('show');
            }
        }
        
        // ä»–ã®å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
        document.addEventListener('click', function(e) {
            if (!e.target.classList.contains('param-help')) {
                document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('show'));
            }
        });
        
        // ========================================
        // ãƒ“ãƒ•ã‚©ãƒ¼ã‚¢ãƒ•ã‚¿ãƒ¼æ¯”è¼ƒæ©Ÿèƒ½
        // ========================================
        function saveForCompare() {
            if (!selectedStage) return;
            
            savedState = {
                growth: growthPower,
                organic: organicNature,
                time: timeFlow,
                stage: selectedStage
            };
            
            // ãƒ“ãƒ•ã‚©ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’æç”»
            const beforeCanvas = document.getElementById('compare-before');
            const sourceCanvas = document.getElementById(`canvas-${selectedStage}`);
            if (beforeCanvas && sourceCanvas) {
                const ctx = beforeCanvas.getContext('2d');
                ctx.clearRect(0, 0, 150, 150);
                ctx.drawImage(sourceCanvas, 0, 0, 150, 150);
            }
        }
        
        function showCompare() {
            if (!savedState || !selectedStage) return;
            
            const compareSection = document.getElementById('compare-section');
            compareSection.style.display = 'block';
            
            // ã‚¢ãƒ•ã‚¿ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’æç”»
            const afterCanvas = document.getElementById('compare-after');
            const sourceCanvas = document.getElementById(`canvas-${selectedStage}`);
            if (afterCanvas && sourceCanvas) {
                const ctx = afterCanvas.getContext('2d');
                ctx.clearRect(0, 0, 150, 150);
                ctx.drawImage(sourceCanvas, 0, 0, 150, 150);
            }
        }
        
        function hideCompare() {
            document.getElementById('compare-section').style.display = 'none';
        }
        
        function saveCurrentState() {
            saveForCompare();
            alert('âœ“ ç¾åœ¨ã®çŠ¶æ…‹ã‚’è¨˜éŒ²ã—ã¾ã—ãŸ');
        }
        const stageNames = [
            '',
            '1. ç¨® - é›ªã«çœ ã‚‹',
            '2. èŠ½ - å…‰ã¸çªç ´',
            '3. è‹¥æœ¨ - é¢¨ã«æºã‚Œã‚‹',
            '4. æˆé•· - å¹´è¼ªã®è¨˜æ†¶',
            '5. æœ¨æ - ä¼æ¡ã®ç¬é–“',
            '6. åŠ å·¥ - ãƒ‡ã‚¸ã‚¿ãƒ«ã¨æ‰‹',
            '7. ç«¯æ - æ®‹ã•ã‚ŒãŸè¨˜æ†¶',
            '8. å†ç”Ÿ - é›†ã†æ–­ç‰‡',
            '9. æœªæ¥ - ç„¡é™ã®å¾ªç’°'
        ];
        
        // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è§£èª¬
        const stageAlgorithms = [
            '', // index 0 is empty
            'Phyllotaxis (è‘‰åº): é»„é‡‘è§’137.5Â°ã‚’ç”¨ã„ãŸèºæ—‹é…ç½®',
            'L-system & Perlin Noise: ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«æˆé•·ã¨æœ‰æ©Ÿçš„æºã‚‰ã',
            'Perlin Noise Field: é¢¨ã®ãƒ™ã‚¯ãƒˆãƒ«å ´ã¨æµä½“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³',
            'Concentric Noise: æ™‚é–“è»¸æ–¹å‘ã®åŒå¿ƒå††ãƒã‚¤ã‚ºç”Ÿæˆ',
            'Random Walk & Parametric Curve: ç¢ºç‡çš„ãªæ­©è¡Œã¨æ•°å¼æ›²ç·š',
            'Grid System & Wave Function: è¦å‰‡çš„ã‚°ãƒªãƒƒãƒ‰ã¨æ­£å¼¦æ³¢åˆæˆ',
            'Voronoi Diagram: ç©ºé–“åˆ†å‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹æ–­ç‰‡åŒ–',
            'Fractal Network: å†å¸°çš„ãªåˆ†å²æ§‹é€ ã«ã‚ˆã‚‹ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯',
            'Logarithmic Spiral: å¯¾æ•°èºæ—‹ã¨ç²’å­ç³»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³'
        ];
        
        // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç‰©èªã®æƒ…æ™¯ï¼ˆå®Œå…¨ç‰ˆãƒ»ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—è§£èª¬è³‡æ–™ã‚ˆã‚Šï¼‰
        const stageScenes = [
            '', // index 0 is empty
            // Stage 1: ç¨®å­
            'ç››å²¡ã®å†¬ã®å¤œç©ºã®ä¸‹ã€é›ªã«è¦†ã‚ã‚ŒãŸå¤§åœ°ã§ã€å”æ¾ã®ç¨®å­ãŒé™ã‹ã«æœªæ¥ã‚’å¾…ã¤ã€‚å‡ã¦ã¤ãåœŸã®ä¸­ã«ã€ã™ã¹ã¦ã®å¯èƒ½æ€§ãŒå‡ç¸®ã•ã‚Œã¦ã„ã‚‹ã€‚',
            // Stage 2: èŠ½
            'åœ°ä¸­ã®æš—é—‡ã‹ã‚‰ã€å…‰ã‚’æ±‚ã‚ã¦çªãæŠœã‘ã‚‹çˆ†ç™ºçš„ãªã‚¨ãƒãƒ«ã‚®ãƒ¼ã€‚æ ¹ã¯è¤‡é›‘ã«çµ¡ã¿åˆã„ãªãŒã‚‰åœŸå£Œã‚’ä¿æŒã—ã€èŠ½ã¯é‡åŠ›ã«é€†ã‚‰ã£ã¦ä¸Šæ˜‡ã™ã‚‹ã€‚ç”Ÿå‘½ã®æ„å¿—ãŒãã“ã«ã‚ã‚‹ã€‚',
            // Stage 3: è‹¥æœ¨
            'åŒ—ä¸Šç›†åœ°ã‚’å¹ãæŠœã‘ã‚‹é¢¨ãŒã€è‹¥æœ¨ã®æã‚’æºã‚‰ã—ã€æ£®å…¨ä½“ãŒå‘¼å¸ã™ã‚‹ã€‚ç›®ã«ã¯è¦‹ãˆãªã„ãŒã€ç¢ºã‹ã«å­˜åœ¨ã™ã‚‹åŠ›â€”ãã‚Œã‚’æ„Ÿã˜ã‚‹èƒ½åŠ›ã‚’ã€ç§ãŸã¡ã¯æŒã£ã¦ã„ã‚‹ã€‚',
            // Stage 4: æˆé•·
            'æ˜¥å¤ç§‹å†¬ã€80å¹´åˆ†ã®æ°—å€™ãŒæ¨¹çš®ã«åˆ»ã¾ã‚Œã¦ã„ãã€‚è±Šä½œã®å¹´ã¯å¤ªãã€å†·å®³ã®å¹´ã¯ç´°ãâ€”æœ¨ã¯æ°—å€™ã‚’è¨˜æ†¶ã™ã‚‹ç”ŸããŸè¨˜éŒ²è£…ç½®ã ã€‚',
            // Stage 5: æœ¨æ
            'ä¼æ¡ã€‚ãã‚Œã¯æ­»ã§ã¯ãªãã€æ£®ã®ç”Ÿå‘½ã‹ã‚‰ã€äººã®æš®ã‚‰ã—ã‚’æ”¯ãˆã‚‹ç´ æï¼ˆãƒãƒ†ãƒªã‚¢ãƒ«ï¼‰ã¸ã®ã€Œå½¹å‰²ã®å¤‰å®¹ã€ã§ã™ã€‚ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯å¤±ã‚ã‚Œãšã€å½¢ã‚’å¤‰ãˆã¦å—ã‘ç¶™ãŒã‚Œã‚‹â€”ã“ã‚Œã¯å½¹å‰²ã®ãƒãƒˆãƒ³ã‚¿ãƒƒãƒãªã®ã§ã™ã€‚',
            // Stage 6: åŠ å·¥
            'è·äººã®æ‰‹ã§ã€å®¶å…·ã‚„é“å…·ã«ç”Ÿã¾ã‚Œå¤‰ã‚ã‚‹ã€‚CNCãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç²¾å¯†ãªè»Œè·¡ã¨ã€æ‰‹é‰‹ã®æ¸©ã‹ãªæºã‚‰ãã€‚ã‚°ãƒªãƒƒãƒ‰ã‚·ã‚¹ãƒ†ãƒ  vs ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯â€”ãƒ‡ã‚¸ã‚¿ãƒ«ã®å®Œç’§ã•ã¨ã€æ‰‹ä»•äº‹ã®ä¸å®Œå…¨ãªç¾ã—ã•ãŒå…±å­˜ã™ã‚‹ã€‚',
            // Stage 7: ç«¯æ
            'å®¶å…·ã«ãªã‚‰ãªã‹ã£ãŸå°ã•ãªæœ¨ç‰‡ãŸã¡ã€‚ã—ã‹ã—ãã“ã«ã‚‚å¹´è¼ªã¯å®¿ã‚Šã€80å¹´ã®è¨˜æ†¶ãŒåˆ»ã¾ã‚Œã¦ã„ã‚‹ã€‚æ¨ã¦ã‚‰ã‚Œã‚‹ã®ã§ã¯ãªãã€æ–°ãŸãªä¾¡å€¤ã¨ã—ã¦å†æ§‹æˆã•ã‚Œã‚‹ã®ã‚’å¾…ã£ã¦ã„ã‚‹ã€‚',
            // Stage 8: å†ç”Ÿ
            'ç«¯æã‹ã‚‰é¤Šåˆ†ãŒæµã‚Œã€åœŸã¸é‚„ã‚Šã€æ–°ã—ã„ç¨®å­ãŒç”Ÿã¾ã‚Œã‚‹æº–å‚™ãŒæ•´ã†ã€‚çµ‚ã‚ã‚Šã¯å§‹ã¾ã‚Šã€‚æ­»ã¯æ–°ã—ã„ç”Ÿå‘½ã®æ¯ã€‚ã“ã“ã«ã€Œå¾ªç’°ã€ã®æœ¬è³ªãŒã‚ã‚‹ã€‚',
            // Stage 9: æœªæ¥
            'ç¨®å­ãŒå®‡å®™ã¸ã€éŠ€æ²³ã¸ã€‚èºæ—‹ã‚’æããªãŒã‚‰åºƒãŒã‚‹ç„¡é™ã®å¯èƒ½æ€§ã€‚ã‚ªã‚¦ãƒ ã‚¬ã‚¤ã®æ®»ã€éŠ€æ²³ã®è…•ã€å°é¢¨ã®æ¸¦â€”ã™ã¹ã¦ãŒåŒã˜å½¢ã€‚ãƒŸã‚¯ãƒ­ã¨ãƒã‚¯ãƒ­ã€éå»ã¨æœªæ¥ãŒä¸€ã¤ã«ã¤ãªãŒã‚‹ã€‚'
        ];
        
        // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®é­”æ³•ã‚¿ã‚°ï¼ˆãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—è§£èª¬è³‡æ–™ã‚ˆã‚Šï¼‰
        const stageMagicTags = [
            '', // index 0 is empty
            'é»„é‡‘è§’137.5Â° | ãƒ•ã‚£ãƒœãƒŠãƒƒãƒ | DNAèºæ—‹ | ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«',
            'L-system | Perlinãƒã‚¤ã‚º | ãƒ™ã‚¸ã‚§æ›²ç·š',
            'Perlinãƒã‚¤ã‚ºãƒ•ãƒ­ãƒ¼ | ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«',
            'ãƒ•ãƒ¼ãƒªã‚¨ç´šæ•° | åŒå¿ƒå††æ³¢å‹• | å‘¨æœŸé–¢æ•°',
            'ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ•ãƒ­ãƒ¼ | å¹¾ä½•å­¦ã‚°ãƒªãƒƒãƒ‰ | ãƒ•ãƒ¼ãƒªã‚¨ç´šæ•°',
            'ãƒœãƒ­ãƒã‚¤å›³ | Delaunayä¸‰è§’å½¢ | CNCãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹',
            'é‡åŠ›ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | é»„é‡‘è§’èºæ—‹ | ãƒ™ã‚¸ã‚§æ›²ç·š',
            'é¤Šåˆ†ãƒ•ãƒ­ãƒ¼ | èŒç³¸ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ | L-system',
            'å¯¾æ•°èºæ—‹ | é»„é‡‘æ¯”Ï† | è‡ªå·±ç›¸ä¼¼å½¢'
        ];
        
        // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®é­”æ³•ã®èª¬æ˜ï¼ˆå®Œå…¨ç‰ˆãƒ»ãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—è§£èª¬è³‡æ–™ã‚ˆã‚Šï¼‰
        const stageMagicDesc = [
            '', // index 0 is empty
            // Stage 1: ç¨®å­
            'è‡ªç„¶ç•Œã§æœ€ã‚‚åŠ¹ç‡çš„ãªé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚ã‚‹é»„é‡‘è§’ï¼ˆ137.5Â°ï¼‰â€”ãƒ’ãƒãƒ¯ãƒªã®ç¨®ãŒç¾ã—ãä¸¦ã¶ã‚ˆã†ã«ã€é™ã‚‰ã‚ŒãŸç©ºé–“ã§æœ€å¤§é™ã®æ§‹é€ ã‚’å®Ÿç¾ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã€‚ãã‚Œã¯38å„„å¹´ã®ç”Ÿå‘½é€²åŒ–ãŒè¦‹ã¤ã‘ãŸæœ€é©è§£ã§ã™ã€‚é»„é‡‘æ¯”Ï†ï¼ˆ1.618â€¦ï¼‰ã¯ã€å®‡å®™ã®ç¾ã®æ³•å‰‡ãã®ã‚‚ã®ã§ã™ã€‚ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ï¼ˆå†å¸°çš„ãªè‡ªå·±ç›¸ä¼¼å½¢ï¼‰ã«ã‚ˆã‚Šã€ç„¡é™ã®è¤‡é›‘ã•ã‚’å˜ç´”ãªãƒ«ãƒ¼ãƒ«ã‹ã‚‰ç”Ÿæˆã—ã¾ã™ã€‚',
            // Stage 2: èŠ½
            'L-systemï¼ˆãƒªãƒ³ãƒ‡ãƒ³ãƒã‚¤ãƒ¤ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼‰ã¯ã€æ¤ç‰©ã®æˆé•·ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹æ–‡æ³•ã€‚ã€ŒF â†’ F[+F][-F]ã€ã®ã‚ˆã†ãªå˜ç´”ãªãƒ«ãƒ¼ãƒ«ã®å†å¸°çš„ãªç¹°ã‚Šè¿”ã—ã‹ã‚‰ã€æœ¨ã®æã‚„è¡€ç®¡ã®ã‚ˆã†ãªè¤‡é›‘ãªæ§‹é€ ã‚’ç”Ÿã¿å‡ºã—ã¾ã™ã€‚ã“ã‚Œã¯ã€Œå‰µç™ºã€â€”éƒ¨åˆ†ã®ç·å’Œã‚’è¶…ãˆãŸå…¨ä½“ãŒç¾ã‚Œã‚‹ç¬é–“ã§ã™ã€‚Perlinãƒã‚¤ã‚ºã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚ã‚ŠãªãŒã‚‰é€£ç¶šçš„ã§è‡ªç„¶ãªæºã‚‰ãã‚’å®Ÿç¾ã™ã‚‹æ•°å­¦çš„æ‰‹æ³•ã€‚',
            // Stage 3: è‹¥æœ¨
            'ã‚±ãƒ³ãƒ»ãƒ‘ãƒ¼ãƒªãƒ³ãŒç™ºæ˜ã—ãŸãƒã‚¤ã‚ºé–¢æ•°ã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚ã‚ŠãªãŒã‚‰é€£ç¶šçš„ã§è‡ªç„¶ãªæºã‚‰ãã‚’ç”Ÿæˆã—ã¾ã™ã€‚å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒPerlinãƒã‚¤ã‚ºã‹ã‚‰å–å¾—ã—ãŸè§’åº¦ã«å¾“ã£ã¦ç§»å‹•ã™ã‚‹ã“ã¨ã§ã€ç›®ã«è¦‹ãˆãªã„é¢¨ã®æµã‚Œã‚’1000å€‹ä»¥ä¸Šã®ç²’å­ã§å¯è¦–åŒ–ã€‚é›²ã€ç‚ã€æ°´â€”æµä½“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦ã€ç§ãŸã¡ã¯ã€Œè¦‹ãˆãªã„ã‚‚ã®ã‚’è¦‹ã‚‹ã€åŠ›ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ãŸã€‚',
            // Stage 4: æˆé•·
            'ã‚¸ãƒ§ã‚¼ãƒ•ãƒ»ãƒ•ãƒ¼ãƒªã‚¨ãŒç™ºè¦‹ã—ãŸã€Œæ³¢ã®é‡ã­åˆã‚ã›ã€ã®åŸç†ã€‚è¤‡é›‘ãªæ³¢å½¢ã‚‚ã€å˜ç´”ãªæ­£å¼¦æ³¢ï¼ˆã‚µã‚¤ãƒ³æ³¢ï¼‰ã®å’Œã¨ã—ã¦è¡¨ç¾ã§ãã‚‹â€”ã“ã‚Œã¯éŸ³æ¥½ã€å…‰ã€ãã—ã¦æ™‚é–“ãã®ã‚‚ã®ã‚’è¨˜è¿°ã™ã‚‹æ•°å­¦ã§ã™ã€‚å®Ÿéš›ã®æ°—å€™ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå‘¨æœŸé–¢æ•°ã‚’é‡ã­åˆã‚ã›ã‚‹ã“ã¨ã§ã€ãƒªã‚¢ãƒ«ãªå¹´è¼ªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆã€‚å¹´è¼ªã¯ã€æ™‚é–“ã‚’ç©ºé–“ã«å¤‰æ›ã—ãŸã€Œãƒ‡ãƒ¼ã‚¿ã®ç‰©è³ªåŒ–ã€ãªã®ã§ã™ã€‚',
            // Stage 5: æœ¨æ
            'æ£®ã‹ã‚‰è¡—ã¸ã€ç”Ÿå‘½ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒç§»å‹•ã™ã‚‹ã€‚ç›´ç·šçš„ãªã‚°ãƒªãƒƒãƒ‰ã¯äººé–“ã®ç†æ€§ã¨ç§©åºã‚’è±¡å¾´ã—ã€æœ‰æ©Ÿçš„ãªæµã‚Œã¯è‡ªç„¶ã®åŠ›ã‚’è¡¨ã—ã¾ã™ã€‚äºŒã¤ã®ä¸–ç•ŒãŒå‡ºä¼šã†ç¬é–“ã§ã™ã€‚ãƒ•ãƒ¼ãƒªã‚¨ç´šæ•°ã«ã‚ˆã‚Šã€è¤‡æ•°å‘¨æ³¢æ•°ã®æ³¢ã‚’é‡ã­åˆã‚ã›ã¦é‡è‘‰ã®ç¹Šç´°ãªæ³¢ã‚’è¡¨ç¾ã€‚æ£®ã¨éƒ½å¸‚ã‚’ã¤ãªãç”Ÿå‘½ãƒ‘ãƒ«ã‚¹ã®ä¼æ’­ã€‚',
            // Stage 6: åŠ å·¥
            'ãƒœãƒ­ãƒã‚¤å›³ã¯ã€ç©ºé–“ã‚’ã€Œæœ€ã‚‚è¿‘ã„ç‚¹ã€ã§åˆ†å‰²ã™ã‚‹å¹¾ä½•å­¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã€‚ç´°èƒã€ã‚­ãƒªãƒ³ã®æ¨¡æ§˜ã€é ˜åœŸã®å¢ƒç•Œç·šâ€”è‡ªç„¶ã‚‚ç¤¾ä¼šã‚‚ã€ã“ã®åŸç†ã§ç©ºé–“ã‚’åˆ†ã‘åˆã£ã¦ã„ã¾ã™ã€‚æ•°å­¦ã¯ã€è‡ªç„¶ç•Œã«æ½œã‚€ç§©åºã‚’æ˜ã‚‰ã‹ã«ã—ã¾ã™ã€‚ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ•ã‚¡ãƒ–ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ¬è³ªã¯ã€ã€Œãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ â†’ å·¥ä½œæ©Ÿæ¢°ã®å‹•ä½œã€ã¸ã®å¤‰æ›ã€‚ã“ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯ã€äººã¨ãƒã‚·ãƒ³ã®å”åƒã‚’è¡¨ç¾ã€‚',
            // Stage 7: ç«¯æ
            'é‡åŠ›ã«å¾“ã£ã¦èˆã„è½ã¡ã‚‹è»Œè·¡ã¯ã€æ”¾ç‰©ç·šï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šï¼‰ã‚’æãã¾ã™ã€‚ã‚¬ãƒªãƒ¬ã‚ªãŒç™ºè¦‹ã—ãŸæ³•å‰‡â€”ã™ã¹ã¦ã®ç‰©ä½“ã¯ç­‰ã—ãè½ä¸‹ã™ã‚‹ã€‚ç«¯æã‚‚ã€å®Œæˆå“ã‚‚ã€ç­‰ã—ãä¾¡å€¤ã‚’æŒã¤ã¨ã„ã†æ€æƒ³ãŒã“ã“ã«ã‚ã‚Šã¾ã™ã€‚æ™‚é–“ã‚’é€šã˜ãŸã€Œæ‹¡æ•£ â†’ æœ€å¤§æ•£ä¹± â†’ åæŸã€ã®ã‚µã‚¤ã‚¯ãƒ«ã‚’è¡¨ç¾ã€‚',
            // Stage 8: å†ç”Ÿ
            'èŒé¡ã®èŒç³¸ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼ˆMycelial Networkï¼‰ã¯ã€æ£®ã®åœ°ä¸‹ã§æœ¨ã€…ã‚’ã¤ãªãã€é¤Šåˆ†ã‚’åˆ†é…ã™ã‚‹ã€Œã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã€ã§ã™ã€‚åˆ†è§£è€…ã¯ç ´å£Šè€…ã§ã¯ãªãã€ç”Ÿå‘½ã®å¾ªç’°ã‚’æ”¯ãˆã‚‹å”åŠ›è€…ã€‚Stage 8ã¯Stage 1ã®ç¨®å­ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆPhyllotaxisã€DNAèºæ—‹ï¼‰ã‚’ä¸­å¿ƒã«å†ç¾ã—ã€çµ‚ã‚ã‚ŠãŒæ–°ã—ã„å§‹ã¾ã‚Šã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ç¾ã€‚æ°¸é ã®å¾ªç’°ã‚’æ•°å­¦çš„ã«è¨˜è¿°ã—ã¾ã™ã€‚',
            // Stage 9: æœªæ¥
            'å¯¾æ•°èºæ—‹ï¼ˆLogarithmic Spiralï¼‰â€”ãã‚Œã¯æˆé•·ã—ã¦ã‚‚å½¢ã‚’å¤‰ãˆãªã„ã€æ°¸é ã®ç¾ã®è±¡å¾´ã§ã™ã€‚ã‚ªã‚¦ãƒ ã‚¬ã‚¤ã€éŠ€æ²³ã€å°é¢¨ã€DNAã®äºŒé‡èºæ—‹â€”ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤‰ã‚ã£ã¦ã‚‚åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç¾ã‚Œã‚‹ã€Œè‡ªå·±ç›¸ä¼¼å½¢ï¼ˆãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ï¼‰ã€ã€‚é»„é‡‘æ¯”ï¼ˆÏ† = 1.618â€¦ï¼‰ã¯ã€ãƒ’ãƒãƒ¯ãƒªã®ç¨®ã®é…ç½®ã€ã‚ªã‚¦ãƒ ã‚¬ã‚¤ã®æ®»ã€ãã—ã¦éŠ€æ²³ã®æ¸¦å·»ãã«ã‚‚ç¾ã‚Œã‚‹æ™®éçš„æ¯”ç‡ã€‚ãƒŸã‚¯ãƒ­ï¼ˆç¨®å­ï¼‰ã¨ãƒã‚¯ãƒ­ï¼ˆéŠ€æ²³ï¼‰ã‚’åŒã˜æ•°å­¦æ³•å‰‡ã§è¡¨ç¾ã—ã€ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¶…ãˆãŸç”Ÿå‘½ã®æœ¬è³ªã‚’ç¤ºã—ã¾ã™ã€‚'
        ];
        
        // å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç‰©èªãƒ»è§£èª¬ï¼ˆå¾“æ¥ç‰ˆã€äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
        const stageStories = [
            '', // index 0 is empty
            'é›ªæ·±ã„ç››å²¡ã®æ£®ã§ã€ä¸€ç²’ã®ç¨®å­ãŒæ˜¥ã‚’å¾…ã¤ã€‚ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã«å¾“ã†è‘‰åºï¼ˆPhyllotaxisï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€è‡ªç„¶ç•Œã§æœ€ã‚‚åŠ¹ç‡çš„ãªé…ç½®ã€‚137.5Â°ã®é»„é‡‘è§’ãŒã€ç„¡é™ã®å¯èƒ½æ€§ã‚’ç§˜ã‚ãŸç”Ÿå‘½ã®è¨­è¨ˆå›³ã‚’æãã€‚',
            'é›ªè§£ã‘ã¨ã¨ã‚‚ã«ã€ç¨®ã¯å¤§åœ°ã‚’çªãç ´ã‚‹ã€‚L-systemã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒæããƒ•ãƒ©ã‚¯ã‚¿ãƒ«æˆé•·ã¯ã€å˜ç´”ãªãƒ«ãƒ¼ãƒ«ã‹ã‚‰è¤‡é›‘ãªå½¢ã‚’ç”Ÿã¿å‡ºã™è‡ªç„¶ã®çŸ¥æµã€‚å…‰ã¸å‘ã‹ã†è¡å‹•ãŒã€æœ€åˆã®æåˆ†ã‹ã‚Œã‚’æ±ºã‚ã‚‹ã€‚',
            'é¢¨ãŒå¹ã‘ã°ã€è‹¥ã„å”æ¾ã¯å…¨èº«ã§å¿œãˆã‚‹ã€‚Perlin NoiseãŒç”Ÿã‚€æœ‰æ©Ÿçš„ãªæºã‚‰ãã¯ã€æ±ºã—ã¦åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¹°ã‚Šè¿”ã•ãªã„ã€‚é¢¨ã¨ã®å¯¾è©±ãŒã€ã—ãªã‚„ã‹ã§å¼·ã„å¹¹ã‚’è‚²ã¦ã‚‹ã€‚',
            '100å¹´ã®æ­³æœˆãŒã€å¹´è¼ªã«åˆ»ã¾ã‚Œã‚‹ã€‚æ˜¥ã®æŸ”ã‚‰ã‹ãªæ—©æã€ç§‹ã®ç¡¬ã„æ™©æã€‚åŒå¿ƒå††ã«è¨˜éŒ²ã•ã‚ŒãŸæ°—å€™ã®è¨˜æ†¶ã¯ã€æœ¨æã®å¼·åº¦ã¨ç¾ã—ã•ã®æºã€‚æ™‚é–“ãŒç©å±¤ã¨ãªã£ã¦ä¾¡å€¤ã‚’ç”Ÿã‚€ã€‚',
            'ä¼æ¡ã¯çµ‚ã‚ã‚Šã§ã¯ãªãã€æ–°ãŸãªå§‹ã¾ã‚Šã€‚100å¹´è‚²ã£ãŸæœ¨ãŒã€äººã®æš®ã‚‰ã—ã‚’100å¹´æ”¯ãˆã‚‹ã€‚ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã§è¡¨ç¾ã•ã‚ŒãŸæ–­é¢ã¯ã€å¤‰å®¹ã®ç¬é–“ã‚’æ‰ãˆã‚‹ã€‚å½¹å‰²ã®ãƒãƒˆãƒ³ã‚¿ãƒƒãƒã€‚',
            'CNCã®ç²¾å¯†ãªã‚°ãƒªãƒƒãƒ‰ã¨ã€è·äººã®æ‰‹ã«ã‚ˆã‚‹é‰‹ã®æ³¢ç´‹ã€‚ãƒ‡ã‚¸ã‚¿ãƒ«ã¨æ‰‹ä»•äº‹ãŒèåˆã™ã‚‹ç¬é–“ã€‚èŸ»ç¶™ãã®å¹¾ä½•å­¦ã¯ã€é‡˜ã‚’ä½¿ã‚ãšæœ¨ã¨æœ¨ã‚’çµã¶å…ˆäººã®çŸ¥æµã€‚æ–°æ—§ã®æŠ€è¡“ãŒå¯¾è©±ã™ã‚‹ã€‚',
            'åŠ å·¥ã§ç”Ÿã¾ã‚Œã‚‹ç«¯æã¯ã€å»ƒæ£„ç‰©ã§ã¯ãªã„ã€‚ãƒœãƒ­ãƒã‚¤å›³ã®ã‚ˆã†ã«é ˜åŸŸã‚’åˆ†ã‘åˆã„ã€æ–°ãŸãªä¾¡å€¤ã‚’å¾…ã¤æ–­ç‰‡ãŸã¡ã€‚æ•£ã‚‰ã°ã£ãŸè¨˜æ†¶ãŒã€å‰µé€ çš„æ´»ç”¨ã«ã‚ˆã£ã¦å†ã³é›†ã¾ã‚‹äºˆæ„Ÿã€‚',
            'åœŸã«é‚„ã‚‹æœ¨æã‚’ã€èŒç³¸ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãŒåˆ†è§£ã™ã‚‹ã€‚L-systemã§åºƒãŒã‚‹åœ°ä¸‹ã®å¾ªç’°ã¯ã€ç›®ã«è¦‹ãˆãªã„æ£®ã®å¿ƒè‡“ã€‚åˆ†è§£ã•ã‚ŒãŸé¤Šåˆ†ã¯ã€æ¬¡ã®ç”Ÿå‘½ã‚’è‚²ã‚€ç³§ã¨ãªã‚‹ã€‚çµ‚ã‚ã‚ŠãŒå§‹ã¾ã‚Šã«ã€‚',
            'ä¸€æœ¬ã®å”æ¾ã®å¾ªç’°ãŒã€å®‡å®™ã®å¾ªç’°ã¨é‡ãªã‚‹ã€‚å¯¾æ•°èºæ—‹ã¯ã€å°é¢¨ã‚‚éŠ€æ²³ã‚‚è²«ãæ™®éçš„ãªå½¢ã€‚æ˜Ÿã€…ã®é–“ã«ã€æ–°ã—ã„ç¨®å­ãŒæ•£ã‚‰ã°ã‚‹ã€‚ç››å²¡ã®æ£®ã‹ã‚‰ã€ç„¡é™ã®ã‚¹ã‚±ãƒ¼ãƒ«ã¸ã€‚å¾ªç’°ã¯ç¶šãã€‚'
        ];
        
        // ãƒ‘ãƒ¼ãƒªãƒ³ãƒã‚¤ã‚ºå®Ÿè£…
        class PerlinNoise {
            constructor() {
                this.gradients = {};
                this.memory = {};
            }
            
            rand_vect() {
                let theta = seededRandom() * 2 * Math.PI;
                return {x: Math.cos(theta), y: Math.sin(theta)};
            }
            
            dot_prod_grid(x, y, vx, vy) {
                let g_vect;
                let d_vect = {x: x - vx, y: y - vy};
                let grid_key = `${vx},${vy}`;
                
                if (this.gradients[grid_key]) {
                    g_vect = this.gradients[grid_key];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[grid_key] = g_vect;
                }
                
                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            }
            
            smootherstep(x) {
                return 6*x**5 - 15*x**4 + 10*x**3;
            }
            
            interp(x, a, b) {
                return a + this.smootherstep(x) * (b-a);
            }
            
            get(x, y) {
                let mem_key = `${x},${y}`;
                if (this.memory[mem_key]) {
                    return this.memory[mem_key];
                }
                
                let xf = Math.floor(x);
                let yf = Math.floor(y);
                
                let tl = this.dot_prod_grid(x, y, xf, yf);
                let tr = this.dot_prod_grid(x, y, xf+1, yf);
                let bl = this.dot_prod_grid(x, y, xf, yf+1);
                let br = this.dot_prod_grid(x, y, xf+1, yf+1);
                
                let xt = this.interp(x-xf, tl, tr);
                let xb = this.interp(x-xf, bl, br);
                let v = this.interp(y-yf, xt, xb);
                
                this.memory[mem_key] = v;
                return v;
            }
        }
        
        const perlin = new PerlinNoise();
        
        document.getElementById('growth-power').addEventListener('input', (e) => {
            growthPower = parseInt(e.target.value);
            document.getElementById('growth-value').textContent = growthPower + '%';
            generateAllPatterns();
        });
        
        document.getElementById('organic-nature').addEventListener('input', (e) => {
            organicNature = parseInt(e.target.value);
            document.getElementById('organic-value').textContent = organicNature + '%';
            generateAllPatterns();
        });
        
        document.getElementById('time-flow').addEventListener('input', (e) => {
            timeFlow = parseInt(e.target.value);
            document.getElementById('time-value').textContent = timeFlow;
            generateAllPatterns();
        });
        
        function generatePattern(canvas, stage, gp, on, tf) {
            const ctx = canvas.getContext('2d');
            const size = 300;
            canvas.width = size;
            canvas.height = size;
            
            // ç™½èƒŒæ™¯
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);
            
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const center = size / 2;
            const gpNorm = gp / 100;
            const onNorm = on / 100;
            const tfNorm = tf / 100;
            
            const gpEffect = Math.pow(gpNorm, 1.3);
            const onEffect = Math.pow(onNorm, 0.8);
            const weight = 1 + (tfNorm * (stage - 5) / 3);
            
            ctx.save();
            
            switch(stage) {
                case 1: drawSeed(ctx, center, gpEffect, onEffect, weight); break;
                case 2: drawSprout(ctx, center, gpEffect, onEffect, weight); break;
                case 3: drawSapling(ctx, center, gpEffect, onEffect, weight); break;
                case 4: drawGrowth(ctx, center, gpEffect, onEffect, weight); break;
                case 5: drawTimber(ctx, center, gpEffect, onEffect, weight); break;
                case 6: drawProcessing(ctx, center, gpEffect, onEffect, weight); break;
                case 7: drawScrap(ctx, center, gpEffect, onEffect, weight); break;
                case 8: drawRegeneration(ctx, center, gpEffect, onEffect, weight); break;
                case 9: drawFuture(ctx, center, gpEffect, onEffect, weight); break;
            }
            
            ctx.restore();
        }
        
        // 1. ç¨® - çµæ™¶åŒ–ã™ã‚‹æ™‚é–“ï¼ˆçµ±åˆç‰ˆï¼‰
        function drawSeed(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(1);
            
            // === èƒŒæ™¯: ç››å²¡ã®å†¬ã®å¤œç©º ===
            
            // æ˜Ÿåº§ï¼ˆãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ ¼å­é…ç½®ï¼‰
            const goldenAngle = (3 - Math.sqrt(5)) * Math.PI;
            const stars = Math.floor(20 + gp * 40);
            
            for (let i = 0; i < stars; i++) {
                const angle = i * goldenAngle;
                const radius = Math.sqrt(i) * (8 + gp * 5);
                
                // onã§æ˜Ÿã®ä½ç½®ã«æºã‚‰ãã‚’è¿½åŠ 
                const noiseX = perlin.get(i * 0.5, noiseOffset) * on * 6;
                const noiseY = perlin.get(i * 0.5 + 100, noiseOffset) * on * 6;
                const sx = center + radius * Math.cos(angle) + noiseX;
                const sy = center + radius * Math.sin(angle) + noiseY;
                
                if (sx < 20 || sx > 280 || sy < 20 || sy > 280) continue;
                
                const size = 0.3 + seededRandom() * (1.2 + on * 1.5); // onã§æ˜Ÿã®ã‚µã‚¤ã‚ºå¤‰åŒ–
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
                
                // æ˜ã‚‹ã„æ˜Ÿã«ã¯åå­—å…‰
                if (size > 1 && seededRandom() > 0.7) {
                    const crossSize = size * 3;
                    ctx.lineWidth = 0.2;
                    ctx.beginPath();
                    ctx.moveTo(sx - crossSize, sy);
                    ctx.lineTo(sx + crossSize, sy);
                    ctx.moveTo(sx, sy - crossSize);
                    ctx.lineTo(sx, sy + crossSize);
                    ctx.stroke();
                }
            }
            
            // === ã‚³ãƒƒãƒ›é›ªç‰‡ï¼ˆãƒ•ãƒ©ã‚¯ã‚¿ãƒ«é›ªã®çµæ™¶ï¼‰ ===
            
            function drawKochSegment(x1, y1, x2, y2, depth, maxDepth) {
                if (depth > maxDepth) {
                    ctx.lineTo(x2, y2);
                    return;
                }
                
                const dx = x2 - x1;
                const dy = y2 - y1;
                
                // ç·šåˆ†ã‚’3ç­‰åˆ†
                const p1x = x1 + dx / 3;
                const p1y = y1 + dy / 3;
                const p2x = x1 + 2 * dx / 3;
                const p2y = y1 + 2 * dy / 3;
                
                // æ­£ä¸‰è§’å½¢ã®é ‚ç‚¹
                const angle = Math.atan2(dy, dx) - Math.PI / 3;
                const length = Math.sqrt(dx * dx + dy * dy) / 3;
                const px = p1x + length * Math.cos(angle);
                const py = p1y + length * Math.sin(angle);
                
                // å†å¸°çš„ã«æç”»
                drawKochSegment(x1, y1, p1x, p1y, depth + 1, maxDepth);
                drawKochSegment(p1x, p1y, px, py, depth + 1, maxDepth);
                drawKochSegment(px, py, p2x, p2y, depth + 1, maxDepth);
                drawKochSegment(p2x, p2y, x2, y2, depth + 1, maxDepth);
            }
            
            function drawKochSnowflake(cx, cy, size, depth) {
                ctx.beginPath();
                
                for (let i = 0; i < 6; i++) {
                    const angle1 = (i / 6) * Math.PI * 2;
                    const angle2 = ((i + 1) / 6) * Math.PI * 2;
                    
                    const x1 = cx + size * Math.cos(angle1);
                    const y1 = cy + size * Math.sin(angle1);
                    const x2 = cx + size * Math.cos(angle2);
                    const y2 = cy + size * Math.sin(angle2);
                    
                    if (i === 0) ctx.moveTo(x1, y1);
                    drawKochSegment(x1, y1, x2, y2, 0, depth);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // å¤§ããªã‚³ãƒƒãƒ›é›ªç‰‡ï¼ˆé æ™¯ï¼‰
            const largeSnowflakes = Math.floor(3 + gp * 6 + on * 4); // onã§æ•°ã‚‚å¤‰åŒ–
            
            for (let i = 0; i < largeSnowflakes; i++) {
                const x = 60 + seededRandom() * 180 + perlin.get(i * 0.3, noiseOffset) * on * 30;
                const y = 40 + i * 50 + perlin.get(i * 0.3 + 50, noiseOffset) * on * 20;
                const size = 8 + seededRandom() * (10 * gp) + on * 8; // onã§ã‚µã‚¤ã‚ºå¤‰åŒ–
                const depth = Math.floor(1 + gp * 2 + on); // onã§è¤‡é›‘ã•ã‚‚å¤‰åŒ–
                
                ctx.lineWidth = 0.3 + seededRandom() * 0.4 + on * 0.3; // onã§ç·šã®å¤ªã•ã‚‚å¤‰åŒ–
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(seededRandom() * Math.PI / 3);
                drawKochSnowflake(0, 0, size, depth);
                ctx.restore();
            }
            
            // å°ã•ãªé›ªã®çµæ™¶ï¼ˆè¿‘æ™¯ï¼‰
            const smallSnowflakes = Math.floor(25 + gp * 60 * weight);
            
            for (let i = 0; i < smallSnowflakes; i++) {
                const x = 30 + seededRandom() * 240;
                const y = 30 + (i / smallSnowflakes) * 240;
                const size = 1.5 + seededRandom() * (2 + gp * 3);
                const rotation = seededRandom() * Math.PI / 3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                const arms = 6;
                ctx.lineWidth = 0.2 + seededRandom() * 0.3;
                
                for (let j = 0; j < arms; j++) {
                    const angle = (j / arms) * Math.PI * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(size * Math.cos(angle), size * Math.sin(angle));
                    ctx.stroke();
                    
                    if (size > 2.5) {
                        const branchLength = size * 0.35;
                        const branchAngle1 = angle - Math.PI / 6;
                        const branchAngle2 = angle + Math.PI / 6;
                        const branchStart = size * 0.65;
                        
                        const bx = branchStart * Math.cos(angle);
                        const by = branchStart * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.moveTo(bx, by);
                        ctx.lineTo(bx + branchLength * Math.cos(branchAngle1), by + branchLength * Math.sin(branchAngle1));
                        ctx.moveTo(bx, by);
                        ctx.lineTo(bx + branchLength * Math.cos(branchAngle2), by + branchLength * Math.sin(branchAngle2));
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // === ãƒœãƒ­ãƒã‚¤å›³ï¼ˆç©é›ªã®æ°·çµæ™¶æ§‹é€ ï¼‰ ===
            
            const voronoiSeeds = Math.floor(8 + gp * 15);
            const voronoiPoints = [];
            
            for (let i = 0; i < voronoiSeeds; i++) {
                voronoiPoints.push({
                    x: 50 + seededRandom() * 200,
                    y: 100 + seededRandom() * 120
                });
            }
            
            // ç°¡æ˜“ãƒœãƒ­ãƒã‚¤ï¼ˆã‚°ãƒªãƒƒãƒ‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
            const gridSize = 4;
            ctx.lineWidth = 0.2;
            
            for (let x = 40; x < 260; x += gridSize) {
                for (let y = 100; y < 230; y += gridSize) {
                    // æœ€ã‚‚è¿‘ã„æ ¸ã‚’è¦‹ã¤ã‘ã‚‹
                    let minDist = Infinity;
                    let nearestIndex = 0;
                    
                    for (let i = 0; i < voronoiPoints.length; i++) {
                        const dx = x - voronoiPoints[i].x;
                        const dy = y - voronoiPoints[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestIndex = i;
                        }
                    }
                    
                    // å¢ƒç•Œç·šã‚’æç”»ï¼ˆéš£æ¥ã™ã‚‹ã‚°ãƒªãƒƒãƒ‰ãŒç•°ãªã‚‹æ ¸ã«å±ã™ã‚‹å ´åˆï¼‰
                    const checkX = x + gridSize;
                    const checkY = y + gridSize;
                    
                    if (checkX < 260) {
                        let minDist2 = Infinity;
                        let nearestIndex2 = 0;
                        
                        for (let i = 0; i < voronoiPoints.length; i++) {
                            const dx = checkX - voronoiPoints[i].x;
                            const dy = y - voronoiPoints[i].y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < minDist2) {
                                minDist2 = dist;
                                nearestIndex2 = i;
                            }
                        }
                        
                        if (nearestIndex !== nearestIndex2) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(checkX, y);
                            ctx.stroke();
                        }
                    }
                    
                    if (checkY < 230) {
                        let minDist2 = Infinity;
                        let nearestIndex2 = 0;
                        
                        for (let i = 0; i < voronoiPoints.length; i++) {
                            const dx = x - voronoiPoints[i].x;
                            const dy = checkY - voronoiPoints[i].y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < minDist2) {
                                minDist2 = dist;
                                nearestIndex2 = i;
                            }
                        }
                        
                        if (nearestIndex !== nearestIndex2) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, checkY);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // === åœŸã®å±¤ï¼ˆç¨®ã‚’åŒ…ã‚€ç’°å¢ƒï¼‰ ===
            
            // è–„ãæ§ãˆã‚ãªåœŸã®å±¤ï¼ˆ3-5å±¤ã®ã¿ï¼‰
            const soilRings = Math.floor(3 + gp * 2);
            
            for (let ring = 0; ring < soilRings; ring++) {
                const baseRadius = 80 + ring * 15;
                
                ctx.lineWidth = 0.2;
                ctx.beginPath();
                
                const segments = 40;
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const noise = perlin.get(
                        Math.cos(angle) * ring * 0.4 + noiseOffset,
                        Math.sin(angle) * ring * 0.4
                    ) * on * 8;
                    
                    const r = baseRadius + noise;
                    const x = center + r * Math.cos(angle);
                    const y = center + r * Math.sin(angle);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // === ç¨®ã®å†…éƒ¨ä¸–ç•Œ ===
            
            // ç¨®ã®ã‚µã‚¤ã‚ºï¼ˆæˆé•·ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å¤§ããä¾å­˜ï¼‰
            const seedRadius = 15 + gp * 70; // 15ã€œ85mmï¼ˆå¤§å¹…ã«å¢—åŠ ï¼‰
            
            // è‘‰åºãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå°†æ¥ã®æˆé•·ã®è¨­è¨ˆå›³ï¼‰- pattern_06_phyllotaxis_BC
            const phyllotaxisPoints = Math.floor(80 + gp * 150); // 80ã€œ230ç‚¹
            const phyllotaxisScale = seedRadius * 0.95 / Math.sqrt(phyllotaxisPoints);
            const phylloGoldenAngle = 137.5 * (Math.PI / 180);
            
            const phylloCoords = [];
            
            // è‘‰åºã®ç‚¹ã‚’è¨ˆç®—
            for (let i = 1; i <= phyllotaxisPoints; i++) {
                const angle = i * phylloGoldenAngle;
                const radius = phyllotaxisScale * Math.sqrt(i);
                
                // ç¨®ã®åŠå¾„å†…ã«åã‚ã‚‹ï¼ˆã»ã¼å…¨ä½“ã‚’ä½¿ã†ï¼‰
                if (radius < seedRadius * 0.95) {
                    const px = center + radius * Math.cos(angle);
                    const py = center + radius * Math.sin(angle);
                    phylloCoords.push({ x: px, y: py, index: i });
                }
            }
            
            // è‘‰åºã®ç·šï¼ˆæˆé•·ã®è»Œè·¡ï¼‰- pattern_06ã¨åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«
            ctx.lineWidth = 0.3 + gp * 0.4; // æˆé•·ã«å¿œã˜ã¦å¤ªã
            ctx.beginPath();
            
            for (let i = 0; i < phylloCoords.length - 1; i++) {
                const current = phylloCoords[i];
                const next = phylloCoords[i + 1];
                
                if (i === 0) ctx.moveTo(current.x, current.y);
                ctx.lineTo(next.x, next.y);
            }
            ctx.stroke();
            
            // è‘‰åºã®ç‚¹ï¼ˆç´°èƒ/å°†æ¥ã®è‘‰èŠ½ï¼‰- pattern_06ã¨åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«
            const baseDotRadius = 0.5 + gp * 1.0; // æˆé•·ã«å¿œã˜ã¦å¤§ãã
            
            for (let i = 0; i < phylloCoords.length; i++) {
                const point = phylloCoords[i];
                const t = i / phylloCoords.length;
                
                // ä¸­å¿ƒã»ã©å¤§ããï¼ˆå¤ã„ç´°èƒï¼‰ã€å¤–å´ã»ã©å°ã•ãï¼ˆæ–°ã—ã„ç´°èƒï¼‰
                const cellSize = baseDotRadius * (1.5 - t * 0.7);
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, cellSize, 0, Math.PI * 2);
                ctx.fill();
                
                // æˆé•·ã®åŠ›å¼·ã•ãŒé«˜ã„å ´åˆã€å¤–å´ã®ç‚¹ã«æ”¾å°„ç·šï¼ˆç”Ÿå‘½ã®èºå‹•ï¼‰
                if (gp > 0.5 && t > 0.65 && i % 4 === 0) {
                    const rayLength = 3 + gp * 6;
                    const rayAngle = Math.atan2(point.y - center, point.x - center);
                    
                    ctx.lineWidth = 0.4 + gp * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(
                        point.x + rayLength * Math.cos(rayAngle),
                        point.y + rayLength * Math.sin(rayAngle)
                    );
                    ctx.stroke();
                }
            }
            
            // DNAäºŒé‡èºæ—‹ï¼ˆéºä¼æƒ…å ±ï¼‰- è‘‰åºã®æœ€å¥¥ã«æ§ãˆã‚ã«é…ç½®
            const dnaRadius = seedRadius * 0.25; // ã‚ˆã‚Šå°ã•ã
            const dnaTurns = 1.2 + gp * 1.0;
            const dnaSegments = 25;
            
            ctx.lineWidth = 0.25;
            
            // ç¬¬1èºæ—‹
            ctx.beginPath();
            for (let i = 0; i <= dnaSegments; i++) {
                const t = i / dnaSegments;
                const angle = t * dnaTurns * Math.PI * 2;
                const z = t * 2 - 1; // -1 to 1
                
                // 3Dèºæ—‹ã‚’2DæŠ•å½±ï¼ˆç¸®å°ï¼‰
                const x = center + dnaRadius * Math.cos(angle) * (0.3 + z * z * 0.7);
                const y = center + dnaRadius * z;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // ç¬¬2èºæ—‹ï¼ˆ180åº¦ä½ç›¸ãšã‚Œï¼‰
            ctx.beginPath();
            for (let i = 0; i <= dnaSegments; i++) {
                const t = i / dnaSegments;
                const angle = t * dnaTurns * Math.PI * 2 + Math.PI;
                const z = t * 2 - 1;
                
                const x = center + dnaRadius * Math.cos(angle) * (0.3 + z * z * 0.7);
                const y = center + dnaRadius * z;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // å¡©åŸºå¯¾ã®æ©‹ï¼ˆæ§ãˆã‚ã«ï¼‰
            const basePairs = Math.floor(4 + gp * 6);
            ctx.lineWidth = 0.15;
            
            for (let i = 0; i < basePairs; i++) {
                const t = i / basePairs;
                const angle1 = t * dnaTurns * Math.PI * 2;
                const angle2 = angle1 + Math.PI;
                const z = t * 2 - 1;
                
                const scale = 0.3 + z * z * 0.7;
                
                const x1 = center + dnaRadius * Math.cos(angle1) * scale;
                const y1 = center + dnaRadius * z;
                const x2 = center + dnaRadius * Math.cos(angle2) * scale;
                const y2 = center + dnaRadius * z;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // ç¨®ã®å¤–æ®»ï¼ˆç´°ãã€ç¹Šç´°ã«ï¼‰
            ctx.lineWidth = 1.0 + gp * 0.5;
            ctx.beginPath();
            ctx.arc(center, center, seedRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç¨®ã®æ ¸ï¼ˆç”Ÿå‘½ã®ä¸­å¿ƒï¼‰
            const coreRadius = Math.max(2, seedRadius * 0.15);
            ctx.beginPath();
            ctx.arc(center, center, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // é‡å­çš„æºã‚‰ãï¼ˆç”Ÿãã¦ã„ã‚‹è¨¼ï¼‰- ã‚¹ã‚±ãƒ¼ãƒ«ã«åˆã‚ã›ã¦èª¿æ•´
            const quantumFluctuations = Math.floor(15 + gp * 30);
            
            for (let i = 0; i < quantumFluctuations; i++) {
                const angle = (i / quantumFluctuations) * Math.PI * 2 + noiseOffset;
                const r = seedRadius + (3 + gp * 5) + Math.sin(angle * 3 + noiseOffset * 2) * 6 * on;
                const length = (4 + gp * 8) + seededRandom() * (8 * on);
                
                const x1 = center + r * Math.cos(angle);
                const y1 = center + r * Math.sin(angle);
                
                // å¤–å‘ãã¨å†…å‘ãã®ä¸¡æ–¹
                const direction = (i % 2 === 0 ? 1 : -1);
                const fluctAngle = angle + (seededRandom() - 0.5) * Math.PI / 4;
                
                const x2 = x1 + length * Math.cos(fluctAngle) * direction;
                const y2 = y1 + length * Math.sin(fluctAngle) * direction;
                
                ctx.lineWidth = 0.3 + seededRandom() * (0.5 + gp * 0.3);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // === ç”Ÿå‘½ã®ã‚ªãƒ¼ãƒ©ï¼ˆç¨®ã®ç”Ÿå‘½ã‚¨ãƒãƒ«ã‚®ãƒ¼å ´ï¼‰ ===
            
            // å¹´è¼ªã«è¦‹ãˆãªã„ã‚ˆã†ã€ä¸è¦å‰‡ã§æœ‰æ©Ÿçš„ãªã‚¨ãƒãƒ«ã‚®ãƒ¼å ´
            const auraLayers = Math.floor(3 + gp * 6);
            
            for (let i = 0; i < auraLayers; i++) {
                const t = i / auraLayers;
                const energy = 1 - t; // ä¸­å¿ƒã»ã©å¼·ã„
                const baseRadius = seedRadius * (1.1 + t * 0.5) * weight;
                
                ctx.lineWidth = 0.15 + energy * 0.4;
                
                // ä¸è¦å‰‡ãªãƒ‘ãƒ«ã‚¹ï¼ˆè¤‡æ•°ã®å°ã•ãªå¼§ï¼‰
                const pulseCount = Math.floor(6 + gp * 8);
                
                for (let p = 0; p < pulseCount; p++) {
                    const startAngle = (p / pulseCount) * Math.PI * 2;
                    const arcLength = (Math.PI / (pulseCount * 0.8)) * (0.6 + seededRandom() * 0.4);
                    
                    ctx.beginPath();
                    
                    const segments = 8;
                    for (let j = 0; j <= segments; j++) {
                        const angle = startAngle + (j / segments) * arcLength;
                        
                        // æœ‰æ©Ÿçš„ãªæºã‚‰ãï¼ˆonãŒä½ã„ã¨æ•´ã£ãŸå††ã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«ï¼‰
                        const wave = Math.sin(angle * 3 + i * 0.8) * 1.5 * on * on * energy;
                        const noise = perlin.get(
                            Math.cos(angle) * i * 0.3,
                            Math.sin(angle) * i * 0.3 + noiseOffset
                        ) * on * on * 6;
                        
                        const r = baseRadius + wave + noise;
                        const x = center + r * Math.cos(angle);
                        const y = center + r * Math.sin(angle);
                        
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }
        }
        
        // 2. èŠ½ - é‡å­çš„è·³èºï¼ˆæš—é—‡ã‹ã‚‰å…‰ã¸ï¼‰
        function drawSprout(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(2);
            
            const groundLevel = center + 50; // åœ°é¢ã‚’å°‘ã—ä¸‹ã’ã‚‹
            const goldenAngle = (3 - Math.sqrt(5)) * Math.PI; // 137.5Â° é»„é‡‘è§’
            
            // === åœ°ä¸‹ã‚¾ãƒ¼ãƒ³: æš—é—‡ã®ä¸–ç•Œ ===
            
            // åœŸã®åœ°å±¤ï¼ˆæ™‚é–“ã®å †ç©ï¼‰
            const soilLayers = Math.floor(8 + gp * 15);
            
            for (let i = 0; i < soilLayers; i++) {
                const y = groundLevel + 10 + (i / soilLayers) * 80;
                
                ctx.lineWidth = 0.3 + (i % 3 === 0 ? 0.4 : 0);
                ctx.beginPath();
                
                for (let x = 30; x <= 270; x += 3) {
                    // onãŒä½ã„ã¨æ•´ã£ãŸç·šã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«ï¼ˆä¿‚æ•°ã‚’æŠ‘ãˆã‚ã«ï¼‰
                    const noise = perlin.get(x * 0.04, i * 0.3 + noiseOffset) * on * on * 4;
                    const finalY = y + noise;
                    
                    if (x === 30) ctx.moveTo(x, finalY);
                    else ctx.lineTo(x, finalY);
                }
                ctx.stroke();
            }
            
            // åœ°ä¸‹ã®æ°´è„ˆï¼ˆåŒ—ä¸Šå·ã®ä¼æµæ°´ï¼‰
            const waterVeins = Math.floor(2 + gp * 4);
            
            for (let v = 0; v < waterVeins; v++) {
                const startY = groundLevel + 30 + v * 25;
                
                ctx.lineWidth = 0.4 + v * 0.2;
                ctx.beginPath();
                
                const startX = 40;
                const endX = 260;
                const cp1x = 100;
                const cp1y = startY + (seededRandom() - 0.5) * 30 * on;
                const cp2x = 200;
                const cp2y = startY + (seededRandom() - 0.5) * 30 * on;
                
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, startY + (seededRandom() - 0.5) * 20);
                ctx.stroke();
                
                // æ°´æ»´ï¼ˆç”Ÿå‘½ã®æºï¼‰
                const droplets = Math.floor(3 + gp * 6);
                for (let d = 0; d < droplets; d++) {
                    const t = d / droplets;
                    // ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ç‚¹ã‚’è¨ˆç®—
                    const dt = 1 - t;
                    const px = dt * dt * dt * startX + 
                              3 * dt * dt * t * cp1x + 
                              3 * dt * t * t * cp2x + 
                              t * t * t * endX;
                    const py = dt * dt * dt * startY + 
                              3 * dt * dt * t * cp1y + 
                              3 * dt * t * t * cp2y + 
                              t * t * t * (startY + (seededRandom() - 0.5) * 20);
                    
                    ctx.beginPath();
                    ctx.arc(px, py, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // æ ¹ã®L-systemãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
            function drawLSystemRoot(x, y, angle, length, depth, maxDepth, generation) {
                if (depth > maxDepth || length < 2) return;
                
                const segments = 8;
                ctx.lineWidth = (maxDepth - depth + 1) * 0.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                let currentX = x;
                let currentY = y;
                
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    // onãŒä½ã„ã¨æ•´ã£ãŸç·šã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«ï¼ˆä¿‚æ•°ã‚’æŠ‘ãˆã‚ã«ï¼‰
                    const noise = perlin.get(currentX * 0.05 + generation, currentY * 0.05 + depth) * on * on * 3;
                    currentX += (length / segments) * Math.cos(angle) + noise;
                    currentY += (length / segments) * Math.sin(angle) + noise;
                    ctx.lineTo(currentX, currentY);
                }
                ctx.stroke();
                
                // èŒæ ¹èŒï¼ˆå…±ç”Ÿã®ã‚·ãƒ³ãƒœãƒ«ï¼‰
                if (depth === maxDepth) {
                    const mycoCount = Math.floor(2 + gp * 4);
                    for (let m = 0; m < mycoCount; m++) {
                        const mycoAngle = seededRandom() * Math.PI * 2;
                        const mycoR = 3 + seededRandom() * 5;
                        const mx = currentX + mycoR * Math.cos(mycoAngle);
                        const my = currentY + mycoR * Math.sin(mycoAngle);
                        
                        ctx.beginPath();
                        ctx.arc(mx, my, 0.5 + seededRandom() * 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // L-systemåˆ†å²ãƒ«ãƒ¼ãƒ«
                if (depth < maxDepth) {
                    const branchAngle1 = angle - (Math.PI / 6 + goldenAngle * 0.1);
                    const branchAngle2 = angle + (Math.PI / 6 + goldenAngle * 0.1);
                    
                    if (seededRandom() > 0.25) {
                        drawLSystemRoot(currentX, currentY, branchAngle1, length * 0.75, depth + 1, maxDepth, generation);
                    }
                    if (seededRandom() > 0.25) {
                        drawLSystemRoot(currentX, currentY, branchAngle2, length * 0.72, depth + 1, maxDepth, generation);
                    }
                }
            }
            
            const rootDepth = Math.floor(2 + gp * 3);
            const rootCount = Math.floor(3 + gp * 5);
            
            for (let i = 0; i < rootCount; i++) {
                const angle = Math.PI / 2 + (i - rootCount / 2) * (Math.PI / (rootCount * 1.5));
                drawLSystemRoot(center, groundLevel, angle, 20 + gp * 25, 0, rootDepth, i);
            }
            
            // === å¢ƒç•Œ: ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®è†œ ===
            
            // å¹²æ¸‰æ³¢ã«ã‚ˆã‚‹æŒ¯å‹•ã™ã‚‹å¢ƒç•Œ
            const boundaryWaves = Math.floor(3 + on * 5);
            
            for (let wave = 0; wave < boundaryWaves; wave++) {
                const amplitude = 3 + wave * 2;
                const freq1 = 0.08 + wave * 0.02;
                const freq2 = 0.12 + wave * 0.03;
                const offset = wave * 2;
                
                ctx.lineWidth = 0.3 + (boundaryWaves - wave) * 0.2;
                ctx.beginPath();
                
                for (let x = 30; x <= 270; x += 2) {
                    // å¹²æ¸‰ãƒ‘ã‚¿ãƒ¼ãƒ³
                    const interference = Math.sin(x * freq1) + Math.sin(x * freq2);
                    const y = groundLevel + offset + amplitude * interference;
                    
                    if (x === 30) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === ä¸Šæ˜‡ã‚¾ãƒ¼ãƒ³: èŠ½ã®è·³èº ===
            
            const sproutHeight = 70 + gp * 50; // é«˜ã•ã‚’èª¿æ•´ã—ã¦æ å†…ã«åã‚ã‚‹
            
            // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®è»Œè·¡ï¼ˆæ®‹åƒãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
            const afterglowFrames = Math.floor(5 + on * 8);
            
            for (let frame = 0; frame < afterglowFrames; frame++) {
                const t = frame / afterglowFrames;
                const opacity = 0.15 + (1 - t) * 0.3;
                const timeOffset = t * 0.5;
                
                ctx.lineWidth = (1 + gp * 2) * opacity * 3;
                ctx.beginPath();
                
                let sx = center;
                let sy = groundLevel;
                ctx.moveTo(sx, sy);
                
                const segments = 20;
                for (let i = 1; i <= segments; i++) {
                    const s = i / segments;
                    
                    // æ”¾ç‰©ç·šçš„ãªåŠ é€Ÿï¼ˆaÂ·tÂ²ï¼‰
                    const acceleration = Math.pow(s, 0.7 + timeOffset * 0.3);
                    // onãŒä½ã„ã¨æ•´ã£ãŸç·šã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«ï¼ˆä¿‚æ•°ã‚’æŠ‘ãˆã‚ã«ï¼‰
                    const noise = perlin.get(sx * 0.04 + frame * 0.3, i * 0.5 + noiseOffset) * on * on * 4;
                    
                    sx = center + noise;
                    sy = groundLevel - sproutHeight * acceleration;
                    
                    ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            // ãƒ¡ã‚¤ãƒ³ã®èŠ½ï¼ˆæœ€å‰é¢ï¼‰
            ctx.lineWidth = 2.5 + gp * 4;
            ctx.beginPath();
            
            let mainX = center;
            let mainY = groundLevel;
            ctx.moveTo(mainX, mainY);
            
            const mainSegments = 25;
            for (let i = 1; i <= mainSegments; i++) {
                const t = i / mainSegments;
                const acceleration = Math.pow(t, 0.75);
                // onãŒä½ã„ã¨æ•´ã£ãŸç·šã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«ï¼ˆä¿‚æ•°ã‚’æŠ‘ãˆã‚ã«ï¼‰
                const noise = perlin.get(mainX * 0.04, i * 0.5 + noiseOffset) * on * on * 5;
                
                mainX = center + noise;
                mainY = groundLevel - sproutHeight * acceleration;
                
                ctx.lineTo(mainX, mainY);
            }
            ctx.stroke();
            
            // ãƒ•ã‚£ãƒœãƒŠãƒƒãƒèºæ—‹ï¼ˆè‘‰åº - phyllotaxisï¼‰
            const phyllotaxisCount = Math.floor(15 + gp * 35);
            
            for (let i = 0; i < phyllotaxisCount; i++) {
                const angle = i * goldenAngle;
                const radius = Math.sqrt(i) * (2 + gp * 3);
                const heightPos = (i / phyllotaxisCount) * sproutHeight;
                
                const px = mainX + radius * Math.cos(angle);
                const py = groundLevel - heightPos;
                
                // å”æ¾ã®é‡è‘‰
                const needleLength = 3 + gp * 6;
                ctx.lineWidth = 0.3 + gp * 0.5;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(
                    px + needleLength * Math.cos(angle + Math.PI / 2),
                    py + needleLength * Math.sin(angle + Math.PI / 2)
                );
                ctx.stroke();
            }
            
            // === åœ°ä¸Šã‚¾ãƒ¼ãƒ³: å…‰ã®ä¸–ç•Œ ===
            
            // ç››å²¡ã®æœæ—¥ï¼ˆå¹¾ä½•å­¦çš„å¤ªé™½ï¼‰- ã‚µã‚¤ã‚ºèª¿æ•´
            const sunRadius = 8 + gp * 6; // å°ã•ãèª¿æ•´
            const sunX = 240; // å°‘ã—å³ã«
            const sunY = 50;  // å°‘ã—ä¸Šã«
            
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // å¤ªé™½ã‹ã‚‰ã®æ”¾å°„ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ï¼‰
            const sunRays = Math.floor(6 + gp * 10); // æœ¬æ•°ã‚’æ¸›ã‚‰ã™
            for (let i = 0; i < sunRays; i++) {
                const angle = (i / sunRays) * Math.PI * 2;
                const innerR = sunRadius + 3; // çŸ­ã
                const outerR = innerR + 8 + gp * 8; // çŸ­ã
                
                ctx.lineWidth = 0.4 + gp * 0.6;
                ctx.beginPath();
                ctx.moveTo(sunX + innerR * Math.cos(angle), sunY + innerR * Math.sin(angle));
                ctx.lineTo(sunX + outerR * Math.cos(angle), sunY + outerR * Math.sin(angle));
                ctx.stroke();
            }
            
            // å…‰ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«åˆ†è§£ï¼ˆãƒ—ãƒªã‚ºãƒ åŠ¹æœï¼‰
            const spectrumBands = Math.floor(5 + gp * 12);
            
            for (let band = 0; band < spectrumBands; band++) {
                const startY = 40 + band * 3;
                const angle = -Math.PI / 3 + band * 0.05;
                const length = 30 + seededRandom() * (40 * gp);
                
                ctx.lineWidth = 0.2 + seededRandom() * 0.5;
                ctx.beginPath();
                
                const startX = sunX - sunRadius;
                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const x = startX + length * t * Math.cos(angle);
                    const y = startY + length * t * Math.sin(angle);
                    const wave = Math.sin(t * Math.PI * 3) * 2 * on;
                    
                    if (i === 0) ctx.moveTo(x, y + wave);
                    else ctx.lineTo(x, y + wave);
                }
                ctx.stroke();
            }
            
            // ãƒ•ãƒ¬ãƒãƒ«åå°„ï¼ˆèŠ½ã®å…ˆç«¯ã‹ã‚‰ã®æ³¢ç´‹ï¼‰
            const tipX = mainX;
            const tipY = mainY;
            const fresnelRings = Math.floor(8 + gp * 15);
            
            for (let i = 0; i < fresnelRings; i++) {
                const t = i / fresnelRings;
                const radius = (i + 1) * (3 + gp * 2);
                const opacity = 1 - t * 0.8;
                
                ctx.lineWidth = 0.3 + opacity * 0.8;
                ctx.beginPath();
                
                const segments = 24;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const noise = perlin.get(Math.cos(angle) * i * 0.3, Math.sin(angle) * i * 0.3 + noiseOffset) * on * 8;
                    
                    const r = radius + noise;
                    const x = tipX + r * Math.cos(angle);
                    const y = tipY + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // èŠ½ã®å…ˆç«¯ï¼ˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã®é›†ä¸­ç‚¹ï¼‰
            ctx.beginPath();
            ctx.arc(tipX, tipY, 3 + gp * 4, 0, Math.PI * 2);
            ctx.fill();
            
            // å…‰å­ï¼ˆç²’å­æ€§ï¼‰
            const photons = Math.floor(20 + gp * 50 * weight);
            
            for (let i = 0; i < photons; i++) {
                const x = 50 + seededRandom() * 200;
                const y = 30 + seededRandom() * (groundLevel - 60);
                const size = 0.3 + seededRandom() * 1.2;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 3. è‹¥æœ¨ - é¢¨ã«æºã‚Œã‚‹ç”Ÿå‘½ï¼ˆPerlinãƒ•ãƒ­ãƒ¼ï¼‰
        function drawSapling(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(3);
            
            const goldenAngle = (3 - Math.sqrt(5)) * Math.PI; // 137.5Â°
            
            // === Perlinãƒã‚¤ã‚ºãƒ•ãƒ­ãƒ¼ï¼ˆpattern_27/28é¢¨ã®è¡¨ç¾ï¼‰ ===
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è¨­å®šï¼ˆæœ‰æ©Ÿæ€§ã«å¿œã˜ã¦å¯†åº¦ã‚’å¤‰åŒ–ï¼‰
            const numParticles = Math.floor((300 + gp * 1200) * weight); // 300ã€œ1500
            const numSteps = Math.floor(40 + on * 30); // 40ã€œ70æ­©
            const stepLength = 0.6;
            
            // Perlinãƒã‚¤ã‚ºã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆé¢¨ã®å¤§ãã•ï¼‰
            const noiseScale = 0.01 + on * 0.02;
            
            // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è»Œè·¡ã‚’æç”»
            for (let p = 0; p < numParticles; p++) {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªé–‹å§‹ä½ç½®
                let x = 20 + seededRandom() * 260;
                let y = 20 + seededRandom() * 260;
                
                ctx.lineWidth = 0.15 + seededRandom() * 0.2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è»Œè·¡
                for (let step = 0; step < numSteps; step++) {
                    // Perlinãƒã‚¤ã‚ºã‹ã‚‰è§’åº¦ã‚’å–å¾—ï¼ˆ-1ã€œ1ã‚’0ã€œ2Ï€ã«å¤‰æ›ï¼‰
                    const noiseVal = perlin.get(x * noiseScale, y * noiseScale + noiseOffset);
                    const angle = (noiseVal + 1.0) * Math.PI;
                    
                    // æ¬¡ã®ä½ç½®ã¸ç§»å‹•
                    x += Math.cos(angle) * stepLength;
                    y += Math.sin(angle) * stepLength;
                    
                    // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                    if (x < 15 || x > 285 || y < 15 || y > 285) break;
                    
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === å”æ¾ã®è‹¥æœ¨ï¼ˆçœŸå®Ÿã®æˆé•·å½¢æ…‹ï¼‰ ===
            
            const trunkHeight = 100 + gp * 90; // è‹¥æœ¨ã®é«˜ã•
            const trunkBase = center + 95; // æ ¹å…ƒã‚’ä¸‹ã«é…ç½®ï¼ˆä¸Šéƒ¨ã«æˆé•·ã®ä½™ç™½ï¼‰
            
            // é¢¨ã®åŠ›ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ï¼ˆPerlinãƒã‚¤ã‚ºã‹ã‚‰é¢¨åœ§ã‚’å–å¾—ï¼‰
            function getWindForce(x, y) {
                const noiseVal = perlin.get(x * noiseScale, y * noiseScale + noiseOffset);
                // é¢¨ã®è§’åº¦ã¨å¼·ã•
                const angle = (noiseVal + 1.0) * Math.PI;
                const strength = (Math.abs(noiseVal) * 0.5 + 0.5) * on;
                return {
                    x: Math.cos(angle) * strength * 25,
                    y: Math.sin(angle) * strength * 15
                };
            }
            
            // é¢¨ã«ã‚ˆã‚‹æºã‚Œã®è»Œè·¡ï¼ˆè¤‡æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
            const swayFrames = Math.floor(6 + on * 15);
            
            for (let frame = 0; frame < swayFrames; frame++) {
                const t = frame / swayFrames;
                const opacity = 0.1 + (1 - Math.abs(t - 0.5) * 2) * 0.35;
                
                // ä¸»å¹¹ï¼ˆé¢¨åœ§ã«ã‚ˆã‚‹æ¹¾æ›²ï¼‰
                ctx.lineWidth = (1.8 + gp * 2.5) * opacity * 2.5;
                ctx.beginPath();
                
                let accumulatedWindX = 0; // ç´¯ç©é¢¨åœ§
                
                const trunkSegments = 25;
                for (let i = 0; i <= trunkSegments; i++) {
                    const heightRatio = i / trunkSegments;
                    const ty = trunkBase - trunkHeight * heightRatio;
                    
                    // ãã®é«˜ã•ã§ã®é¢¨åœ§
                    const wind = getWindForce(center, ty + frame * 8);
                    
                    // é«˜ã•ã«å¿œã˜ã¦é¢¨åœ§ã‚’è“„ç©ï¼ˆå…ˆç«¯ã»ã©å¤§ããæ›²ãŒã‚‹ï¼‰
                    accumulatedWindX += wind.x * Math.pow(heightRatio, 1.3) * 0.15;
                    
                    const tx = center + accumulatedWindX;
                    
                    if (i === 0) ctx.moveTo(tx, ty);
                    else ctx.lineTo(tx, ty);
                }
                ctx.stroke();
            }
            
            // ãƒ¡ã‚¤ãƒ³ã®ä¸»å¹¹ï¼ˆæœ€ã‚‚æ˜ç¢ºï¼‰
            ctx.lineWidth = 2.8 + gp * 4;
            ctx.beginPath();
            
            let mainTrunkPoints = [];
            let mainAccumulatedWindX = 0;
            
            const mainSegments = 30;
            for (let i = 0; i <= mainSegments; i++) {
                const heightRatio = i / mainSegments;
                const ty = trunkBase - trunkHeight * heightRatio;
                
                const wind = getWindForce(center, ty);
                mainAccumulatedWindX += wind.x * Math.pow(heightRatio, 1.3) * 0.15;
                
                const tx = center + mainAccumulatedWindX + perlin.get(center * 0.02, i * 0.25 + noiseOffset) * on * 8;
                
                mainTrunkPoints.push({ x: tx, y: ty, wind: wind });
                
                if (i === 0) ctx.moveTo(tx, ty);
                else ctx.lineTo(tx, ty);
            }
            ctx.stroke();
            
            // æï¼ˆè¼ªç”Ÿã«è¿‘ã„é…ç½® - å”æ¾ã®ç‰¹å¾´ï¼‰
            const branchWhorls = Math.floor(3 + gp * 5); // æ®µæ•°
            
            for (let whorl = 0; whorl < branchWhorls; whorl++) {
                const whorlHeightRatio = 0.3 + (whorl / branchWhorls) * 0.6;
                const trunkIndex = Math.floor(whorlHeightRatio * mainTrunkPoints.length);
                const trunkPoint = mainTrunkPoints[Math.min(trunkIndex, mainTrunkPoints.length - 1)];
                
                // å„æ®µã«3-5æœ¬ã®æï¼ˆæ”¾å°„çŠ¶ï¼‰
                const branchesPerWhorl = Math.floor(3 + gp * 2);
                
                for (let b = 0; b < branchesPerWhorl; b++) {
                    const branchAngle = (b / branchesPerWhorl) * Math.PI * 2 + whorl * 0.5; // æ®µã”ã¨ã«ãšã‚‰ã™
                    const branchLength = (18 + gp * 25) * (0.7 + whorlHeightRatio * 0.3); // ä¸‹ã®æã»ã©é•·ã„
                    
                    // æã¯æ°´å¹³ã€œã‚„ã‚„ä¸‹å‚
                    const branchDownAngle = -Math.PI / 12; // 15åº¦ä¸‹å‘ã
                    
                    ctx.lineWidth = 1.2 + gp * 1.8;
                    ctx.beginPath();
                    ctx.moveTo(trunkPoint.x, trunkPoint.y);
                    
                    let bx = trunkPoint.x;
                    let by = trunkPoint.y;
                    
                    const branchSegments = 10;
                    let accumulatedBranchWindX = 0;
                    
                    for (let j = 1; j <= branchSegments; j++) {
                        const bt = j / branchSegments;
                        
                        // æã®åŸºæœ¬æ–¹å‘ï¼ˆæ°´å¹³+ä¸‹å‚ï¼‰
                        const horizontalDist = branchLength * bt * Math.cos(branchAngle);
                        const verticalDist = branchLength * bt * Math.sin(branchDownAngle);
                        
                        // é¢¨ã®å½±éŸ¿ï¼ˆæå…ˆã»ã©å¼·ã„ï¼‰
                        const branchWind = getWindForce(bx, by);
                        accumulatedBranchWindX += branchWind.x * bt * 0.25;
                        
                        bx = trunkPoint.x + horizontalDist * Math.cos(0) + accumulatedBranchWindX;
                        by = trunkPoint.y - horizontalDist * Math.sin(0) + verticalDist;
                        
                        bx += perlin.get(bx * 0.04 + b, by * 0.04 + whorl) * on * 8;
                        
                        ctx.lineTo(bx, by);
                    }
                    ctx.stroke();
                    
                    // çŸ­æã«é‡è‘‰ãŒæŸç”Ÿï¼ˆå”æ¾ã®ç‰¹å¾´ï¼‰
                    const shortBranches = Math.floor(5 + gp * 8);
                    
                    for (let s = 0; s < shortBranches; s++) {
                        const st = (s + 1) / (shortBranches + 1);
                        const sbx = trunkPoint.x + branchLength * st * Math.cos(branchAngle) * Math.cos(0) + accumulatedBranchWindX * st;
                        const sby = trunkPoint.y - branchLength * st * Math.cos(branchAngle) * Math.sin(0) + branchLength * st * Math.sin(branchDownAngle);
                        
                        // çŸ­æã«20-40æœ¬ã®é‡è‘‰ãŒæŸç”Ÿï¼ˆãƒ­ã‚¼ãƒƒãƒˆçŠ¶ï¼‰
                        const needlesPerCluster = Math.floor(10 + gp * 20);
                        
                        for (let n = 0; n < needlesPerCluster; n++) {
                            const needleAngle = (n / needlesPerCluster) * Math.PI * 2;
                            const needleLength = 2 + gp * 4;
                            
                            // é‡è‘‰ã‚‚é¢¨ã®å½±éŸ¿ã‚’å—ã‘ã‚‹
                            const needleWind = getWindForce(sbx, sby);
                            const needleWindOffset = needleWind.x * 0.3;
                            
                            ctx.lineWidth = 0.15 + gp * 0.25;
                            ctx.beginPath();
                            ctx.moveTo(sbx, sby);
                            ctx.lineTo(
                                sbx + needleLength * Math.cos(needleAngle) + needleWindOffset,
                                sby + needleLength * Math.sin(needleAngle)
                            );
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // é•·æã®é‡è‘‰ï¼ˆä¸»å¹¹ã«èºæ—‹çŠ¶ã«å˜ç”Ÿï¼‰
            const longBranchNeedles = Math.floor(20 + gp * 40);
            
            for (let i = 0; i < longBranchNeedles; i++) {
                const angle = i * goldenAngle;
                const heightIndex = Math.floor((i / longBranchNeedles) * mainTrunkPoints.length);
                const trunkPoint = mainTrunkPoints[Math.min(heightIndex, mainTrunkPoints.length - 1)];
                
                const needleLength = 3 + gp * 5;
                const wind = getWindForce(trunkPoint.x, trunkPoint.y);
                
                ctx.lineWidth = 0.2 + gp * 0.3;
                ctx.beginPath();
                ctx.moveTo(trunkPoint.x, trunkPoint.y);
                ctx.lineTo(
                    trunkPoint.x + needleLength * Math.cos(angle) + wind.x * 0.2,
                    trunkPoint.y + needleLength * Math.sin(angle)
                );
                ctx.stroke();
            }
            
            // æ ¹ï¼ˆåœ°é¢ã¨ã®æ¥ç¶šï¼‰
            const rootCount = Math.floor(4 + gp * 5);
            
            for (let r = 0; r < rootCount; r++) {
                const rootAngle = (r / rootCount) * Math.PI * 2;
                const rootLength = 18 + gp * 18;
                
                ctx.lineWidth = 1.2 + gp * 1.8;
                ctx.beginPath();
                ctx.moveTo(center, trunkBase);
                
                let rx = center;
                let ry = trunkBase;
                
                const rootSegments = 8;
                for (let j = 1; j <= rootSegments; j++) {
                    const t = j / rootSegments;
                    const downwardAngle = Math.PI / 2 + Math.PI / 6; // ä¸‹å‘ã+åºƒãŒã‚‹
                    
                    rx += (rootLength / rootSegments) * Math.cos(rootAngle);
                    ry += (rootLength / rootSegments) * Math.sin(downwardAngle);
                    rx += perlin.get(rx * 0.03 + r, ry * 0.03) * on * 8;
                    
                    ctx.lineTo(rx, ry);
                }
                ctx.stroke();
            }
        }
        
        // 4. æˆé•· - 100å¹´ã®è¨˜æ†¶ã‚’åˆ»ã‚€å¹´è¼ªï¼ˆçµ±åˆç‰ˆï¼‰
        function drawGrowth(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(4);
            
            // === æ™‚é–“ã®å½±éŸ¿ã‚’åè»¢ï¼ˆéå»=è‹¥ã„=ç´°ã„ã€æœªæ¥=æˆç†Ÿ=å¤ªã„ï¼‰ ===
            // stage 4ã§ã¯ weight ãŒé€†ã«ãªã£ã¦ã„ã‚‹ã®ã§ä¿®æ­£
            const timeEffect = 2 - weight; // weightãŒ0.67(æœªæ¥)â†’1.33ã€weightãŒ1.33(éå»)â†’0.67
            
            // === åŸºæœ¬è¨­å®š ===
            const numYears = Math.floor(20 + gp * 60 * timeEffect); // 20ã€œ80å¹´ï¼ˆé»’æ½°ã‚Œé˜²æ­¢ï¼‰
            const maxRadius = 110 * timeEffect;
            
            // ä¸­å¿ƒã®ã‚ãšã‹ãªãšã‚Œï¼ˆæˆé•·ã®éå¯¾ç§°æ€§ï¼‰
            const centerOffset = {
                x: (seededRandom() - 0.5) * 12 * on,
                y: (seededRandom() - 0.5) * 12 * on
            };
            
            // === 1. ä¸­å¿ƒã®é«„ï¼ˆpithï¼‰===
            const pithRadius = 2 + gp * 3;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(center + centerOffset.x, center + centerOffset.y, pithRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // é«„ã®å‘¨ã‚Šã®ä¸è¦å‰‡ãªå½¢çŠ¶
            ctx.lineWidth = 0.3;
            ctx.beginPath();
            const pithSegments = 12;
            for (let i = 0; i <= pithSegments; i++) {
                const angle = (i / pithSegments) * Math.PI * 2;
                const r = pithRadius + (seededRandom() - 0.5) * 2;
                const x = center + centerOffset.x + r * Math.cos(angle);
                const y = center + centerOffset.y + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // === 2. æ°—å€™å¤‰å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”Ÿæˆï¼ˆé•·æœŸã‚µã‚¤ã‚¯ãƒ«ï¼‰ ===
            // ç››å²¡ã®æ°—å€™ï¼šå¯’å†·æœŸã¨æ¸©æš–æœŸã®11å¹´å‘¨æœŸï¼ˆå¤ªé™½æ´»å‹•ï¼‰+ ãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•
            function getClimateEffect(year) {
                const cycle11 = Math.sin(year * 2 * Math.PI / 11) * 0.3; // 11å¹´å‘¨æœŸ
                const cycle3 = Math.sin(year * 2 * Math.PI / 3.7) * 0.2; // çŸ­æœŸå¤‰å‹•
                const random = perlin.get(year * 0.08, noiseOffset * 0.5) * 0.4;
                return 0.7 + cycle11 + cycle3 + random; // 0.3ã€œ1.3ã®ç¯„å›²
            }
            
            // === 3. æˆé•·æ®µéšã«ã‚ˆã‚‹ç‰¹æ€§å¤‰åŒ– ===
            function getGrowthPhase(year, totalYears) {
                const t = year / totalYears;
                if (t < 0.15) return { phase: 'juvenile', vigor: 0.5, regularity: 0.9 }; // å¹¼å°‘æœŸ
                else if (t < 0.6) return { phase: 'growth', vigor: 1.2, regularity: 0.7 }; // æˆé•·æœŸ
                else return { phase: 'mature', vigor: 0.8, regularity: 0.85 }; // æˆç†ŸæœŸ
            }
            
            // === 4. å¹´è¼ªã®æç”»ï¼ˆæ—©æ + æ™©æã®äºŒå±¤æ§‹é€ ï¼‰ ===
            let currentRadius = pithRadius + 2;
            
            for (let year = 0; year < numYears; year++) {
                const yearProgress = year / numYears;
                const climate = getClimateEffect(year);
                const growthPhase = getGrowthPhase(year, numYears);
                
                // å¹´è¼ªã®å¹…ï¼ˆæ°—å€™ã¨æˆé•·æ®µéšã«å½±éŸ¿ã•ã‚Œã‚‹ï¼‰
                const baseWidth = (maxRadius - pithRadius) / numYears;
                const ringWidth = baseWidth * climate * growthPhase.vigor * timeEffect;
                
                // ã‚ãšã‹ãªèºæ—‹ã®æ»ã‚Œï¼ˆå®Ÿéš›ã®æœ¨ã®ç‰¹æ€§ï¼‰
                const spiralTwist = year * 0.003 * on;
                
                const segments = 96;
                
                // === æ—©æï¼ˆEarlywoodï¼‰: æ˜¥å¤ã®æˆé•·ã€å¤ªãæ˜ã‚‹ã„ ===
                const earlywoodWidth = ringWidth * 0.65;
                ctx.lineWidth = 0.2 + gp * 0.1; // ã•ã‚‰ã«ç´°ãèª¿æ•´
                ctx.beginPath();
                
                for (let j = 0; j <= segments; j++) {
                    const baseAngle = (j / segments) * Math.PI * 2;
                    const angle = baseAngle + spiralTwist;
                    
                    // Perlinãƒã‚¤ã‚ºã§æœ‰æ©Ÿçš„ãªæºã‚‰ã
                    const noise = perlin.get(
                        Math.cos(angle) * year * 0.12 + noiseOffset,
                        Math.sin(angle) * year * 0.12
                    ) * on * 6 * (1 - growthPhase.regularity);
                    
                    // æ–¹å‘æ€§ã®ã‚ã‚‹å¤‰å‹•ï¼ˆæœ¨ã®åå¿ƒæˆé•·ï¼‰
                    const directionalGrowth = Math.cos(angle - Math.PI / 4) * year * 0.05;
                    
                    const r = currentRadius + earlywoodWidth / 2 + noise + directionalGrowth;
                    const x = center + centerOffset.x + r * Math.cos(angle);
                    const y = center + centerOffset.y + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // === æ™©æï¼ˆLatewoodï¼‰: ç§‹å†¬ã®æˆé•·ã€ç´°ãæ¿ƒã„ ===
                currentRadius += earlywoodWidth;
                const latewoodWidth = ringWidth * 0.35;
                
                // æ™©æã¯æ¿ƒãå¼·èª¿ï¼ˆå¯’å†·åœ°ã®ç‰¹å¾´ï¼‰
                ctx.lineWidth = 0.3 + gp * 0.15; // ã•ã‚‰ã«ç´°ãèª¿æ•´
                ctx.beginPath();
                
                for (let j = 0; j <= segments; j++) {
                    const baseAngle = (j / segments) * Math.PI * 2;
                    const angle = baseAngle + spiralTwist;
                    
                    const noise = perlin.get(
                        Math.cos(angle) * year * 0.12 + noiseOffset + 100,
                        Math.sin(angle) * year * 0.12 + 100
                    ) * on * 4 * (1 - growthPhase.regularity);
                    
                    const directionalGrowth = Math.cos(angle - Math.PI / 4) * year * 0.05;
                    
                    const r = currentRadius + latewoodWidth / 2 + noise + directionalGrowth;
                    const x = center + centerOffset.x + r * Math.cos(angle);
                    const y = center + centerOffset.y + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                currentRadius += latewoodWidth;
                
                // === å¾®ç´°ãªå°ç®¡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ5å¹´ãŠãã«å¼·èª¿ï¼‰ ===
                if (year % 5 === 0 && on > 0.3) {
                    const vesselCount = Math.floor(20 + on * 30);
                    for (let v = 0; v < vesselCount; v++) {
                        const angle = (v / vesselCount) * Math.PI * 2 + spiralTwist;
                        const r = currentRadius - ringWidth / 2 + (seededRandom() - 0.5) * ringWidth * 0.8;
                        const vx = center + centerOffset.x + r * Math.cos(angle);
                        const vy = center + centerOffset.y + r * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(vx, vy, 0.2 + seededRandom() * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // === 5. é«„ç·šï¼ˆMedullary raysï¼‰: ä¸­å¿ƒã‹ã‚‰æ”¾å°„ã™ã‚‹çµ„ç¹” ===
            const numRays = Math.floor(12 + gp * 20); // æ•°ã‚’æ¸›ã‚‰ã™
            ctx.lineWidth = 0.1 + on * 0.15; // ã‚ˆã‚Šç´°ã
            
            for (let i = 0; i < numRays; i++) {
                const angle = (i / numRays) * Math.PI * 2 + seededRandom() * 0.1;
                
                ctx.beginPath();
                ctx.moveTo(center + centerOffset.x + pithRadius * Math.cos(angle), 
                          center + centerOffset.y + pithRadius * Math.sin(angle));
                
                // é«„ç·šã¯å¤–å´ã«å‘ã‹ã£ã¦å¤ªãã€æ³¢æ‰“ã¤
                const raySegments = Math.floor(30 + on * 30);
                for (let j = 1; j <= raySegments; j++) {
                    const t = j / raySegments;
                    const r = pithRadius + t * (currentRadius - pithRadius);
                    
                    // å¹´è¼ªã‚’æ¨ªåˆ‡ã‚‹ã¨ãã®æ³¢æ‰“ã¡
                    const wave = perlin.get(i * 1.5, t * 8 + noiseOffset) * on * 6;
                    const rayAngle = angle + wave * 0.05;
                    
                    const x = center + centerOffset.x + r * Math.cos(rayAngle);
                    const y = center + centerOffset.y + r * Math.sin(rayAngle);
                    
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === 6. è¡¨é¢ã®äº€è£‚ã¨ã²ã³å‰²ã‚Œï¼ˆå¤–å´ã«å‘ã‹ã†æ”¾å°„çŠ¶ï¼‰ ===
            if (gp > 0.5) {
                const numCracks = Math.floor((gp - 0.5) * 10); // æ•°ã‚’æ¸›ã‚‰ã™
                ctx.lineWidth = 0.4 + gp * 0.5; // ã•ã‚‰ã«ç´°ãèª¿æ•´
                
                for (let i = 0; i < numCracks; i++) {
                    const angle = seededRandom() * Math.PI * 2;
                    const startR = currentRadius * (0.85 + seededRandom() * 0.1);
                    const endR = currentRadius * (0.95 + seededRandom() * 0.08);
                    
                    ctx.beginPath();
                    ctx.moveTo(center + centerOffset.x + startR * Math.cos(angle),
                              center + centerOffset.y + startR * Math.sin(angle));
                    
                    // äº€è£‚ã¯ä¸è¦å‰‡ã«åºƒãŒã‚‹
                    const crackSegments = 8;
                    for (let j = 1; j <= crackSegments; j++) {
                        const t = j / crackSegments;
                        const r = startR + t * (endR - startR);
                        const wobble = (seededRandom() - 0.5) * 0.15;
                        const crackAngle = angle + wobble;
                        
                        const x = center + centerOffset.x + r * Math.cos(crackAngle);
                        const y = center + centerOffset.y + r * Math.sin(crackAngle);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }
            
            // === 7. æ¨¹çš®ã¸ã®ç§»è¡Œï¼ˆæœ€å¤–å±¤ï¼‰ ===
            if (timeEffect > 0.7) {
                const barkLayers = Math.floor(3 + on * 15);
                ctx.lineWidth = 0.3;
                
                for (let i = 0; i < barkLayers; i++) {
                    const barkRadius = currentRadius + i * 2;
                    ctx.beginPath();
                    
                    const barkSegments = 48;
                    for (let j = 0; j <= barkSegments; j++) {
                        const angle = (j / barkSegments) * Math.PI * 2;
                        const roughness = perlin.get(
                            Math.cos(angle) * i * 2 + noiseOffset,
                            Math.sin(angle) * i * 2
                        ) * on * 8;
                        
                        const r = barkRadius + roughness;
                        const x = center + centerOffset.x + r * Math.cos(angle);
                        const y = center + centerOffset.y + r * Math.sin(angle);
                        
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }
        }
        
        // 5. æœ¨æ - ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®å¤‰å®¹ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯è¡¨ç¾ï¼‰
        function drawTimber(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(5);
            
            const forestZone = center - 50 - gp * 10; // gpã§å·¦ã«åºƒãŒã‚‹
            const cityZone = center + 50 + gp * 10;   // gpã§å³ã«åºƒãŒã‚‹
            
            // === å·¦å´: æ£®ã®ç”Ÿå‘½ã‚¨ãƒãƒ«ã‚®ãƒ¼ ===
            
            // å²©æ‰‹å±±ã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆï¼ˆèƒŒæ™¯ï¼‰
            const mountainBase = 250;
            const mountainPeak = 50 + (1 - gp * 0.5) * 40; // gpã§å±±ã®é«˜ã•ãŒå¤§ããå¤‰åŒ–
            const mountainWidth = 35 + gp * 15; // gpã§å±±ã®å¹…ãŒå¤‰åŒ–
            
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(forestZone - mountainWidth, mountainBase);
            // å·¦æ–œé¢ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯æ›²ç·šï¼‰
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const x = forestZone - mountainWidth + t * mountainWidth;
                const y = mountainBase - Math.pow(t, 0.7) * (mountainBase - mountainPeak);
                const noise = perlin.get(i * 0.3, 0.5 + noiseOffset) * on * 5;
                ctx.lineTo(x, y + noise);
            }
            // å³æ–œé¢
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const x = forestZone + t * mountainWidth;
                const y = mountainPeak + Math.pow(t, 1.4) * (mountainBase - mountainPeak);
                const noise = perlin.get((20 + i) * 0.3, 0.5 + noiseOffset) * on * 8;
                ctx.lineTo(x, y + noise);
            }
            ctx.stroke();
            
            // å”æ¾ã®ç”Ÿå‘½ãƒ‘ãƒ«ã‚¹ï¼ˆåŒå¿ƒå††ã®æ³¢å‹•ï¼‰
            const treePosY = 150 + on * 8; // ä½ç½®ã‚’ä¸Šã’ã¦å¤§ããªå¹´è¼ªã‚‚åã¾ã‚‹ã‚ˆã†ã«
            const pulseWaves = Math.floor(5 + gp * 10 + on * 3); // gp, onã§æ³¢ã®æ•°ãŒå¤‰åŒ–
            
            for (let i = 0; i < pulseWaves; i++) {
                const t = i / pulseWaves;
                const radius = (5 + i * 7 + gp * 4) * weight; // åŠå¾„ã‚’å¤§ãã
                const opacity = 1 - t * 0.6;
                
                ctx.lineWidth = 0.4 + opacity * (1 + gp * 0.5 + on * 0.3); // on ã§ã‚‚å¤ªã•å¤‰åŒ–
                ctx.beginPath();
                
                const segments = 32;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    // onãŒä½ã„ã¨æ•´ã£ãŸå††ã€é«˜ã„ã¨æœ‰æ©Ÿçš„ã«
                    const noise = perlin.get(
                        Math.cos(angle) * i * 0.2 + noiseOffset,
                        Math.sin(angle) * i * 0.2
                    ) * on * on * 5;
                    
                    const r = radius + noise;
                    const x = forestZone + r * Math.cos(angle);
                    const y = treePosY + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // é‡è‘‰ã®æ”¾å°„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå”æ¾ç‰¹æœ‰ï¼‰
            const needleCount = Math.floor(8 + gp * 15 + on * 5); // gp, onã§é‡è‘‰ã®æ•°ãŒå¤‰åŒ–
            
            for (let i = 0; i < needleCount; i++) {
                const angle = (i / needleCount) * Math.PI * 2;
                const length = 10 + gp * 15 + on * 8; // gp, onã§é•·ã•ãŒå¤‰åŒ–
                
                // ãƒ•ãƒ¼ãƒªã‚¨ç´šæ•°çš„ãªæ³¢ï¼ˆé‡è‘‰ã®ç¹Šç´°ã•ï¼‰
                ctx.lineWidth = 0.2 + seededRandom() * (0.3 + gp * 0.3 + on * 0.2); // gp, onã§å¤ªã•å¤‰åŒ–
                ctx.beginPath();
                
                const segments = 15;
                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const r = length * t;
                    
                    // è¤‡æ•°ã®å‘¨æ³¢æ•°ã‚’é‡ã­åˆã‚ã›
                    const wave = Math.sin(t * Math.PI * 4) * 2 * on +
                                Math.sin(t * Math.PI * 8) * 1 * on;
                    
                    const x = forestZone + (r + wave) * Math.cos(angle);
                    const y = treePosY + (r + wave) * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // ç§‹ã®é»„è‘‰ï¼ˆæ³¢ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
            const autumnWaves = Math.floor(3 + gp * 6 + on * 4); // gp, onã§æ³¢ã®æ•°ãŒå¤‰åŒ–
            
            for (let i = 0; i < autumnWaves; i++) {
                const baseY = 120 + i * (18 - gp * 5); // gpã§é–“éš”ãŒå¤‰åŒ–
                const amplitude = 6 + gp * 10 + on * 5; // gp, onã§æŒ¯å¹…ãŒå¤‰åŒ–
                const frequency = 0.15 + i * 0.05;
                
                ctx.lineWidth = 0.4 + i * 0.2;
                ctx.beginPath();
                
                for (let x = forestZone - 30; x <= forestZone + 30; x += 2) { // ç¯„å›²ã‚’ç¸®å°
                    const y = baseY + amplitude * Math.sin(x * frequency + i);
                    const noise = perlin.get(x * 0.05, i * 0.3) * on * 5;
                    
                    if (x === forestZone - 40) ctx.moveTo(x, y + noise);
                    else ctx.lineTo(x, y + noise);
                }
                ctx.stroke();
            }
            
            // === ä¸­å¤®: å¤‰å®¹ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼æµ ===
            
            // åŒ—ä¸Šå·ã®ã‚ˆã†ãªæµã‚Œï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šï¼‰
            const flowCount = Math.floor(15 + gp * 40 * weight);
            
            for (let i = 0; i < flowCount; i++) {
                const startY = 50 + (i / flowCount) * 200;
                const curvature = (seededRandom() - 0.5) * 40 * on;
                
                ctx.lineWidth = 0.2 + seededRandom() * (0.8 * gp);
                ctx.beginPath();
                ctx.moveTo(forestZone + 20, startY);
                
                // 3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã§ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æµã‚Œ
                const cp1x = forestZone + 30;
                const cp1y = startY + curvature;
                const cp2x = cityZone - 30;
                const cp2y = startY - curvature;
                const endX = cityZone - 20;
                const endY = startY + (seededRandom() - 0.5) * 20;
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
            }
            
            // ç²’å­ã®å†æ§‹æˆï¼ˆå¤‰å®¹ã®ç¬é–“ï¼‰
            const particles = Math.floor(30 + gp * 80);
            
            for (let i = 0; i < particles; i++) {
                const t = i / particles;
                const x = center + (seededRandom() - 0.5) * 30;
                const y = 60 + t * 190;
                
                // èºæ—‹é‹å‹•ã™ã‚‹ç²’å­
                const spiralAngle = t * Math.PI * 4;
                const spiralRadius = (seededRandom() - 0.5) * 15 * on;
                const px = x + spiralRadius * Math.cos(spiralAngle);
                const py = y;
                
                const size = 0.5 + seededRandom() * 1.5 * gp;
                
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯æ™‚é–“è»¸ï¼ˆæ­£å¼¦æ³¢ã®é‡ã­åˆã‚ã›ï¼‰
            const timeWaves = Math.floor(3 + gp * 7);
            
            for (let wave = 0; wave < timeWaves; wave++) {
                const amplitude = 15 + wave * 3;
                const frequency = 0.08 + wave * 0.02;
                const phase = wave * (Math.PI / 3);
                
                ctx.lineWidth = 0.3 + wave * 0.15;
                ctx.beginPath();
                
                for (let y = 50; y <= 250; y += 2) {
                    const x = center + amplitude * Math.sin(y * frequency + phase);
                    
                    if (y === 50) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === å³å´: è¡—ã§ã®æ–°ã—ã„ç”Ÿå‘½ ===
            
            // æœ¨ç›®ã®ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯è¡¨ç¾ï¼ˆã‚µã‚¤ãƒ³æ³¢ã®åˆæˆï¼‰
            const grainLayers = Math.floor(20 + gp * 40);
            
            for (let i = 0; i < grainLayers; i++) {
                const y = 80 + (i / grainLayers) * 160; // ç¯„å›²ã‚’èª¿æ•´
                
                ctx.lineWidth = 0.2 + (i % 5 === 0 ? 0.4 : 0);
                ctx.beginPath();
                
                for (let x = cityZone - 35; x <= cityZone + 35; x += 1) { // ç¯„å›²ã‚’ç¸®å°
                    const freq1 = 0.3;
                    const freq2 = 0.8;
                    const amp1 = 3 * on;
                    const amp2 = 1.5 * on;
                    
                    const wave = amp1 * Math.sin(x * freq1 + i * 0.1) +
                                amp2 * Math.sin(x * freq2 + i * 0.2);
                    
                    const finalY = y + wave;
                    
                    if (x === cityZone - 40) ctx.moveTo(x, finalY);
                    else ctx.lineTo(x, finalY);
                }
                ctx.stroke();
            }
            
            // å¹¾ä½•å­¦çš„ãªå®¶å…·ãƒ‘ã‚¿ãƒ¼ãƒ³
            const furniturePatterns = Math.floor(2 + gp * 4);
            
            for (let i = 0; i < furniturePatterns; i++) {
                const py = 100 + i * 50;
                const size = 20 + gp * 15;
                
                // é»„é‡‘æ¯”çš„ãªé…ç½®
                const phi = (1 + Math.sqrt(5)) / 2;
                const smallSize = size / phi;
                
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                // çŸ©å½¢ã®å…¥ã‚Œå­ï¼ˆãƒ•ã‚£ãƒœãƒŠãƒƒãƒçš„ï¼‰
                ctx.rect(cityZone - size / 2, py, size, size / phi);
                ctx.rect(cityZone - size / 2, py, smallSize, smallSize);
                ctx.stroke();
                
                // å¯¾è§’ç·šï¼ˆæ§‹é€ ã®ç¾ï¼‰
                ctx.lineWidth = 0.4;
                ctx.beginPath();
                ctx.moveTo(cityZone - size / 2, py);
                ctx.lineTo(cityZone + size / 2, py + size / phi);
                ctx.moveTo(cityZone + size / 2, py);
                ctx.lineTo(cityZone - size / 2, py + size / phi);
                ctx.stroke();
            }
            
            // ç”Ÿå‘½ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®ç¶™ç¶šï¼ˆç‚­ç´ å›ºå®šã®æ³¢å‹•ï¼‰
            const carbonWaves = Math.floor(8 + gp * 15);
            
            for (let i = 0; i < carbonWaves; i++) {
                const angle = (i / carbonWaves) * Math.PI;
                const radius = 25 + i * 3;
                
                ctx.lineWidth = 0.3 + (carbonWaves - i) * 0.05;
                ctx.beginPath();
                
                const segments = 20;
                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const a = angle + t * Math.PI;
                    const r = radius + Math.sin(t * Math.PI * 3) * 3 * on;
                    
                    const x = cityZone + r * Math.cos(a);
                    const y = 240 + r * Math.sin(a);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === å¾ªç’°ã®å®Œçµ: æ£®â†’è¡—â†’æ£® ===
            
            // å¤§ããªå¾ªç’°ã®å¼§ï¼ˆå¯¾æ•°èºæ—‹çš„ï¼‰
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            
            const arcSegments = 50;
            for (let i = 0; i <= arcSegments; i++) {
                const t = i / arcSegments;
                
                // è¡—ã‹ã‚‰æ£®ã¸é‚„ã‚‹è»Œè·¡ï¼ˆã‚«ãƒ†ãƒŠãƒªãƒ¼æ›²ç·šçš„ï¼‰
                const x = cityZone + (forestZone - cityZone) * t;
                const sag = Math.sin(t * Math.PI) * 25;
                const y = 265 + sag;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // å¾ªç’°ã‚’ç¤ºã™è¨˜å·ï¼ˆâˆï¼‰
            ctx.font = '12px serif';
            ctx.fillText('âˆ', center - 5, 278);
        }
        
        // 6. åŠ å·¥ - æ™‚ç³»åˆ—ã®åŠ å·¥ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆçµ±åˆç‰ˆï¼‰
        function drawProcessing(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(6);
            
            // === ç”»é¢ã‚’4åˆ†å‰²ã™ã‚‹ã‚¾ãƒ¼ãƒ³ ===
            const zones = {
                topLeft: { x: 30, y: 30, w: 120, h: 120 },    // åŸæœ¨ã®æ–­é¢
                topRight: { x: 150, y: 30, w: 120, h: 120 },  // CNCåˆ‡å‰Š
                bottomLeft: { x: 30, y: 150, w: 120, h: 120 }, // æ‰‹ä»•äº‹
                bottomRight: { x: 150, y: 150, w: 120, h: 120 } // å®Œæˆã—ãŸç¶™æ‰‹
            };
            
            // === å…¨ä½“ã«é€ã‘ã‚‹æœ¨ç›®ï¼ˆèƒŒæ™¯ï¼‰- gpã§å¯†åº¦ãŒåŠ‡çš„ã«å¤‰åŒ– ===
            const baseGrain = Math.floor(20 + gp * 80 * weight); // 20ã€œ100
            ctx.lineWidth = 0.1 + gp * 0.2; // å¤ªã•ã‚‚å¤‰åŒ–
            
            for (let i = 0; i < baseGrain; i++) {
                const y = 30 + (i / baseGrain) * 240;
                ctx.beginPath();
                
                for (let x = 30; x <= 270; x += 2) {
                    const noise = perlin.get(x * 0.02, i * 0.3 + noiseOffset) * on * 6 * (1 + weight * 0.5); // æŒ¯å¹…å¼·åŒ–
                    const finalY = y + noise;
                    
                    if (x === 30) ctx.moveTo(x, finalY);
                    else ctx.lineTo(x, finalY);
                }
                ctx.stroke();
            }
            
            // === 1. å·¦ä¸Š: åŸæœ¨ã®æ–­é¢ã¨æœ¨å–ã‚Š ===
            const z1 = zones.topLeft;
            const ringCenterX = z1.x + z1.w / 2;
            const ringCenterY = z1.y + z1.h / 2;
            const numRings = Math.floor(8 + gp * 25 * weight); // weightã§å¹´è¼ªæ•°ãŒå¤‰åŒ–
            
            // ä¸­å¿ƒã®é«„
            const pithSize = 1.5 + gp * 2;
            ctx.beginPath();
            ctx.arc(ringCenterX, ringCenterY, pithSize, 0, Math.PI * 2);
            ctx.fill();
            
            // å¹´è¼ªï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã«å¤‰åŒ–ï¼‰
            for (let i = 1; i <= numRings; i++) {
                const t = i / numRings;
                const baseRadius = t * (z1.w / 2 - 5);
                const isLatewood = (i % 2 === 0);
                
                // ç·šã®å¤ªã•ã‚’ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã«å¤‰åŒ–
                ctx.lineWidth = isLatewood ? 
                    (0.3 + gp * 0.4 + weight * 0.2) : 
                    (0.2 + gp * 0.2);
                
                ctx.beginPath();
                
                const segments = 48;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    // æœ‰æ©Ÿæ€§ã§æºã‚‰ãã‚’å¼·åŒ–
                    const noise = perlin.get(
                        Math.cos(angle) * i * 0.2 + noiseOffset,
                        Math.sin(angle) * i * 0.2
                    ) * on * 5 * (1 + weight * 0.5);
                    
                    const r = baseRadius + noise;
                    const x = ringCenterX + r * Math.cos(angle);
                    const y = ringCenterY + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // === æœ¨å–ã‚Šç·šï¼ˆè£½ææ‰€ã§ã®åˆ‡æ–­è¨ˆç”»ï¼‰ ===
            // gpãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§æœ¨å–ã‚Šã®è¤‡é›‘ã•ãŒå¤‰åŒ–
            
            const logRadius = z1.w / 2 - 5;
            const kidoriComplexity = Math.floor(1 + gp * 3); // 1ã€œ4æ®µéš
            
            ctx.lineWidth = 1.2 + gp * 1.2 + on * 0.5;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)'; // å°‘ã—è–„ã
            
            if (kidoriComplexity >= 1) {
                // === ãƒ‘ã‚¿ãƒ¼ãƒ³1: åŸºæœ¬ã®åå­—åˆ‡ã‚Šï¼ˆå¿ƒæŒã¡æï¼‰ ===
                // ä¸­å¿ƒã‚’é€šã‚‹å‚ç›´ç·š
                ctx.beginPath();
                ctx.moveTo(ringCenterX, ringCenterY - logRadius);
                ctx.lineTo(ringCenterX, ringCenterY + logRadius);
                ctx.stroke();
                
                // ä¸­å¿ƒã‚’é€šã‚‹æ°´å¹³ç·š
                ctx.beginPath();
                ctx.moveTo(ringCenterX - logRadius, ringCenterY);
                ctx.lineTo(ringCenterX + logRadius, ringCenterY);
                ctx.stroke();
            }
            
            if (kidoriComplexity >= 2) {
                // === ãƒ‘ã‚¿ãƒ¼ãƒ³2: æ¿ç›®æã®åˆ‡ã‚Šå‡ºã— ===
                const boardSpacing = logRadius * 0.5;
                
                // å·¦å³ã®æ¿æ
                for (let side = -1; side <= 1; side += 2) {
                    const xPos = ringCenterX + side * boardSpacing;
                    ctx.beginPath();
                    ctx.moveTo(xPos, ringCenterY - logRadius);
                    ctx.lineTo(xPos, ringCenterY + logRadius);
                    ctx.stroke();
                }
                
                // ä¸Šä¸‹ã®æ¿æ
                for (let side = -1; side <= 1; side += 2) {
                    const yPos = ringCenterY + side * boardSpacing;
                    ctx.beginPath();
                    ctx.moveTo(ringCenterX - logRadius, yPos);
                    ctx.lineTo(ringCenterX + logRadius, yPos);
                    ctx.stroke();
                }
            }
            
            if (kidoriComplexity >= 3) {
                // === ãƒ‘ã‚¿ãƒ¼ãƒ³3: æŸ¾ç›®æï¼ˆæ”¾å°„çŠ¶ï¼‰ ===
                const numRadialCuts = 4;
                
                for (let i = 0; i < numRadialCuts; i++) {
                    const angle = (i / numRadialCuts) * Math.PI * 2 + Math.PI / 8;
                    ctx.beginPath();
                    ctx.moveTo(ringCenterX, ringCenterY);
                    ctx.lineTo(
                        ringCenterX + logRadius * Math.cos(angle),
                        ringCenterY + logRadius * Math.sin(angle)
                    );
                    ctx.stroke();
                }
            }
            
            if (kidoriComplexity >= 4) {
                // === ãƒ‘ã‚¿ãƒ¼ãƒ³4: ç´°ã‹ã„åˆ†å‰²ï¼ˆåŠ¹ç‡çš„ãªæœ¨å–ã‚Šï¼‰ ===
                const fineSpacing = logRadius * 0.3;
                
                // ç´°ã‹ã„ç¸¦ç·š
                for (let i = -1; i <= 1; i++) {
                    if (i === 0) continue;
                    const xPos = ringCenterX + i * fineSpacing * 1.5;
                    ctx.lineWidth = 0.6 + gp * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(xPos, ringCenterY - logRadius * 0.7);
                    ctx.lineTo(xPos, ringCenterY + logRadius * 0.7);
                    ctx.stroke();
                }
            }
            
            // æ‰‹ä½œæ¥­ã®æºã‚‰ãï¼ˆonãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰
            if (on > 0.3) {
                // ã®ã“ãã‚Šã®å¾®ç´°ãªæºã‚Œ
                const sawMarks = Math.floor(on * 20);
                ctx.lineWidth = 0.15 + on * 0.2;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                
                for (let i = 0; i < sawMarks; i++) {
                    const angle = seededRandom() * Math.PI * 2;
                    const dist = seededRandom() * logRadius * 0.8;
                    const x = ringCenterX + dist * Math.cos(angle);
                    const y = ringCenterY + dist * Math.sin(angle);
                    const len = 2 + seededRandom() * 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(x - len, y);
                    ctx.lineTo(x + len, y);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = 'black'; // å…ƒã«æˆ»ã™
            
            // === 2. å³ä¸Š: CNCã«ã‚ˆã‚‹åˆ‡å‰Š ===
            const z2 = zones.topRight;
            const cncCenterX = z2.x + z2.w / 2;
            const cncCenterY = z2.y + z2.h / 2;
            
            // CNCãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹ï¼ˆãƒ•ã‚£ãƒœãƒŠãƒƒãƒèºæ—‹ï¼‰- gpã§å¯†åº¦ãŒå¤‰åŒ–ï¼ˆé»’æ½°ã‚Œé˜²æ­¢ï¼‰
            const spiralPoints = Math.floor(30 + gp * 250 * weight); // 30ã€œ280ç‚¹
            const goldenAngle = (3 - Math.sqrt(5)) * Math.PI;
            
            ctx.lineWidth = 0.15 + gp * 0.25; // ç´°ã‚ã«èª¿æ•´
            
            for (let i = 1; i < spiralPoints; i++) {
                const t = i / spiralPoints;
                const angle = i * goldenAngle;
                const radius = Math.sqrt(i) * (z2.w / 2 - 10) / Math.sqrt(spiralPoints);
                
                const x1 = cncCenterX + radius * Math.cos(angle);
                const y1 = cncCenterY + radius * Math.sin(angle);
                
                const nextAngle = (i + 1) * goldenAngle;
                const nextRadius = Math.sqrt(i + 1) * (z2.w / 2 - 10) / Math.sqrt(spiralPoints);
                const x2 = cncCenterX + nextRadius * Math.cos(nextAngle);
                const y2 = cncCenterY + nextRadius * Math.sin(nextAngle);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // ãƒ“ãƒƒãƒˆè·¡ï¼ˆå††å¼§ï¼‰- é »åº¦ã‚’æ¸›ã‚‰ã™
                if (i % 25 === 0 && on > 0.4) {
                    ctx.lineWidth = 0.15;
                    ctx.beginPath();
                    ctx.arc(x1, y1, 0.6 + gp * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 0.15 + gp * 0.25; // æˆ»ã™
                }
            }
            
            // æœ¨å±‘ã®ç²’å­ï¼ˆCNCåˆ‡å‰Šã«ã‚ˆã‚‹ï¼‰- å¯†åº¦ã‚’æ¸›ã‚‰ã™
            const cncChips = Math.floor(8 + on * 30 * weight); // 8ã€œ38å€‹
            for (let i = 0; i < cncChips; i++) {
                const angle = seededRandom() * Math.PI * 2;
                const dist = seededRandom() * (z2.w / 2);
                const x = cncCenterX + dist * Math.cos(angle);
                const y = cncCenterY + dist * Math.sin(angle);
                const size = 0.2 + seededRandom() * (0.8 + on * 1.2); // ã‚µã‚¤ã‚ºã‚‚èª¿æ•´
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // CADã‚°ãƒªãƒƒãƒ‰ï¼ˆè–„ãï¼‰- gpã§å¯†åº¦ãŒå¤‰åŒ–
            if (gp > 0.3) {
                ctx.lineWidth = 0.1 + gp * 0.2;
                const gridStep = 20 - gp * 12; // 20ã€œ8pxï¼ˆå¯†åº¦ãŒä¸ŠãŒã‚‹ï¼‰
                
                for (let gx = z2.x; gx <= z2.x + z2.w; gx += gridStep) {
                    ctx.beginPath();
                    ctx.moveTo(gx, z2.y);
                    ctx.lineTo(gx, z2.y + z2.h);
                    ctx.stroke();
                }
                
                for (let gy = z2.y; gy <= z2.y + z2.h; gy += gridStep) {
                    ctx.beginPath();
                    ctx.moveTo(z2.x, gy);
                    ctx.lineTo(z2.x + z2.w, gy);
                    ctx.stroke();
                }
            }
            
            // === 3. å·¦ä¸‹: è·äººã®æ‰‹ä»•äº‹ ===
            const z3 = zones.bottomLeft;
            
            // é‰‹ï¼ˆã‹ã‚“ãªï¼‰ã®è»Œè·¡ - é•·ãé€£ç¶šã—ãŸæ³¢ï¼ˆonã§å¯†åº¦ãŒåŠ‡çš„ã«å¤‰åŒ–ï¼‰
            const planeStrokes = Math.floor(5 + on * 25 * weight); // 5ã€œ30
            
            for (let i = 0; i < planeStrokes; i++) {
                const startY = z3.y + 10 + (i / planeStrokes) * (z3.h - 20);
                
                ctx.lineWidth = 0.3 + seededRandom() * (0.4 + on * 1.2); // å¤ªã•ã‚‚å¤‰åŒ–
                ctx.beginPath();
                
                for (let x = z3.x + 5; x <= z3.x + z3.w - 5; x += 1.5) {
                    const t = (x - z3.x - 5) / (z3.w - 10);
                    
                    // é‰‹ã®æ³¢ï¼ˆæ‰‹ã®æºã‚‰ã + åŠ›ã®å¼·å¼±ï¼‰- onã§æŒ¯å¹…ãŒå¤§ããå¤‰åŒ–
                    const breath = Math.sin(t * Math.PI * 3) * on * 6; // å‘¼å¸ã®ãƒªã‚ºãƒ å¼·åŒ–
                    const tremor = perlin.get(x * 0.05, i + noiseOffset) * on * 8; // æºã‚‰ãå¼·åŒ–
                    
                    const y = startY + breath + tremor;
                    
                    if (x === z3.x + 5) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // é‘¿ï¼ˆã®ã¿ï¼‰ã®å½«ã‚Šè·¡ - Vå­—å‹ï¼ˆonã§æ•°ãŒåŠ‡çš„ã«å¤‰åŒ–ï¼‰
            const chiselMarks = Math.floor(3 + on * 20 * weight); // 3ã€œ23
            
            for (let i = 0; i < chiselMarks; i++) {
                const cx = z3.x + 15 + seededRandom() * (z3.w - 30);
                const cy = z3.y + 15 + seededRandom() * (z3.h - 30);
                const size = 2 + seededRandom() * (5 + on * 20); // ã‚µã‚¤ã‚ºã‚‚å¤‰åŒ–
                const angle = seededRandom() * Math.PI * 2;
                
                ctx.lineWidth = 0.5 + seededRandom() * (0.8 + on * 1.5); // å¤ªã•ã‚‚å¤‰åŒ–
                ctx.beginPath();
                
                const x1 = cx + size * Math.cos(angle - Math.PI / 6);
                const y1 = cy + size * Math.sin(angle - Math.PI / 6);
                const x2 = cx + size * Math.cos(angle + Math.PI / 6);
                const y2 = cy + size * Math.sin(angle + Math.PI / 6);
                
                ctx.moveTo(x1, y1);
                ctx.lineTo(cx, cy);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // æœ¨å±‘ã®ã‚«ãƒ¼ãƒ«ï¼ˆèºæ—‹çŠ¶ï¼‰- gpã¨onã§æ•°ã¨è¤‡é›‘ã•ãŒå¤‰åŒ–
            const shavings = Math.floor(2 + gp * 20 * weight); // 2ã€œ22
            
            for (let i = 0; i < shavings; i++) {
                const startX = z3.x + 20 + seededRandom() * (z3.w - 40);
                const startY = z3.y + 20 + seededRandom() * (z3.h - 40);
                
                ctx.lineWidth = 0.2 + seededRandom() * (0.3 + on * 0.8); // å¤ªã•ã‚‚å¤‰åŒ–
                ctx.beginPath();
                
                const spiralTurns = 1.5 + seededRandom() * (2 + gp * 4); // è¤‡é›‘ã•å¢—åŠ 
                const spiralRadius = 4 + seededRandom() * (8 + gp * 10); // ã‚µã‚¤ã‚ºã‚‚å¢—åŠ 
                const points = 30;
                
                for (let j = 0; j <= points; j++) {
                    const t = j / points;
                    const angle = t * Math.PI * 2 * spiralTurns;
                    const r = spiralRadius * t;
                    
                    const x = startX + r * Math.cos(angle);
                    const y = startY + r * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // === 4. å³ä¸‹: å®Œæˆã—ãŸç¶™æ‰‹ï¼ˆèŸ»ç¶™ãï¼‰- çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚‹å¼·å›ºãªä¸€ä½“åŒ– ===
            const z4 = zones.bottomRight;
            const jointCenterX = z4.x + z4.w / 2;
            const jointCenterY = z4.y + z4.h / 2;
            
            // gpã§ç¶™æ‰‹ã®è¤‡é›‘ã•ãŒåŠ‡çš„ã«å¤‰åŒ–
            const numTeeth = Math.floor(1 + gp * 7 * weight); // 1ã€œ8ã®æ­¯ï¼ˆå°‘ãªã‚ã«ï¼‰
            const jointWidth = (z4.w - 25) * (0.6 + gp * 0.4); // 60%ã€œ100%ï¼ˆå¹…ã‚‚åŠ‡çš„ã«å¤‰åŒ–ï¼‰
            const jointHeight = 20 + gp * 55 + weight * 12; // é«˜ã•ã‚‚åŠ‡çš„ã«å¤‰åŒ–
            
            // èŸ»ã®è§’åº¦ãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§åŠ‡çš„ã«å¤‰åŒ–ï¼ˆgpãŒé«˜ã„ã»ã©æ€¥è§’åº¦ï¼‰
            const dovetailAngle = 0.1 + gp * 0.4; // 0.1ã€œ0.5ï¼ˆæµ…ã„ã€œæ€¥ï¼‰
            
            // èŸ»ã®å¹…ã®æ¯”ç‡ï¼ˆgpã§åŠ‡çš„ã«å¤‰åŒ–ï¼‰
            const teethWidthRatio = 0.25 + gp * 0.45; // 0.25ã€œ0.7ï¼ˆç‹­ã„ã€œåºƒã„ï¼‰
            
            // === çµ„ã¿åˆã‚ã›ã®é€²è¡Œåº¦ï¼ˆgpã§å¤‰åŒ–ï¼‰ ===
            // gpãŒä½ã„ï¼šåˆ†é›¢çŠ¶æ…‹ï¼ˆåŠ å·¥ç›´å¾Œï¼‰
            // gpãŒé«˜ã„ï¼šå®Œå…¨çµåˆï¼ˆå¼·å›ºãªä¸€ä½“åŒ–ï¼‰
            const assemblyProgress = Math.pow(gp, 1.8); // 0ã€œ1ï¼ˆã‚ˆã‚ŠæŒ‡æ•°é–¢æ•°çš„ã«å¤‰åŒ–ï¼‰
            const gapSize = (1 - assemblyProgress) * 35; // 35pxã€œ0pxï¼ˆéš™é–“ã‚’å¤§ããï¼‰
            
            ctx.lineWidth = 0.5 + gp * 1 + weight * 0.5; // å¤ªã•ã‚‚åŠ‡çš„ã«å¤‰åŒ–
            
            // ä¸Šå´ã®ãƒ”ãƒ¼ã‚¹ï¼ˆå‡¸ï¼‰- éš™é–“åˆ†ã ã‘ä¸Šã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            const upperOffsetY = -gapSize / 2;
            
            ctx.beginPath();
            ctx.moveTo(jointCenterX - jointWidth / 2, jointCenterY - jointHeight / 2 + upperOffsetY);
            
            for (let i = 0; i < numTeeth; i++) {
                const baseT = i / numTeeth;
                const nextBaseT = (i + 1) / numTeeth;
                const teethWidth = teethWidthRatio / numTeeth;
                
                const t1 = baseT;
                const t2 = baseT + (1 - teethWidthRatio) / (2 * numTeeth);
                const t3 = baseT + (1 + teethWidthRatio) / (2 * numTeeth);
                const t4 = nextBaseT;
                
                const x1 = jointCenterX - jointWidth / 2 + t1 * jointWidth;
                const x2 = jointCenterX - jointWidth / 2 + t2 * jointWidth;
                const x3 = jointCenterX - jointWidth / 2 + t3 * jointWidth;
                const x4 = jointCenterX - jointWidth / 2 + t4 * jointWidth;
                
                const y1 = jointCenterY - jointHeight / 2 + upperOffsetY;
                const y2 = jointCenterY - jointHeight / 2 + jointHeight * dovetailAngle + upperOffsetY;
                
                // æ‰‹ä½œæ¥­ã®å¾®ç´°ãªæºã‚‰ãï¼ˆonãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰
                const tremor1 = perlin.get(i * 0.8, noiseOffset) * on * 2 * (1 - assemblyProgress * 0.8);
                const tremor2 = perlin.get(i * 0.8 + 0.3, noiseOffset) * on * 2 * (1 - assemblyProgress * 0.8);
                
                // å°å½¢ã®èŸ»ï¼ˆè§’åº¦ãŒå¤‰åŒ–ã™ã‚‹ï¼‰
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2 + tremor1, y2);
                ctx.lineTo(x3 + tremor2, y2);
                ctx.lineTo(x4, y1);
            }
            ctx.lineTo(jointCenterX + jointWidth / 2, jointCenterY - jointHeight / 2 + upperOffsetY);
            ctx.stroke();
            
            // ä¸‹å´ã®ãƒ”ãƒ¼ã‚¹ï¼ˆå‡¹ï¼‰- éš™é–“åˆ†ã ã‘ä¸‹ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            const lowerOffsetY = gapSize / 2;
            
            ctx.beginPath();
            ctx.moveTo(jointCenterX - jointWidth / 2, jointCenterY + jointHeight / 2 + lowerOffsetY);
            
            for (let i = 0; i < numTeeth; i++) {
                const baseT = i / numTeeth;
                const nextBaseT = (i + 1) / numTeeth;
                const teethWidth = teethWidthRatio / numTeeth;
                
                const t1 = baseT;
                const t2 = baseT + (1 - teethWidthRatio) / (2 * numTeeth);
                const t3 = baseT + (1 + teethWidthRatio) / (2 * numTeeth);
                const t4 = nextBaseT;
                
                const x1 = jointCenterX - jointWidth / 2 + t1 * jointWidth;
                const x2 = jointCenterX - jointWidth / 2 + t2 * jointWidth;
                const x3 = jointCenterX - jointWidth / 2 + t3 * jointWidth;
                const x4 = jointCenterX - jointWidth / 2 + t4 * jointWidth;
                
                const y1 = jointCenterY + jointHeight / 2 + lowerOffsetY;
                const y2 = jointCenterY + jointHeight / 2 - jointHeight * dovetailAngle + lowerOffsetY;
                
                // æ‰‹ä½œæ¥­ã®å¾®ç´°ãªæºã‚‰ãï¼ˆçµ„ã¿åˆã‚ã›ãŒé€²ã‚€ã¨æ¸›å°‘ï¼‰
                const tremor1 = perlin.get(i * 0.8 + 100, noiseOffset) * on * 2 * (1 - assemblyProgress * 0.8);
                const tremor2 = perlin.get(i * 0.8 + 100.3, noiseOffset) * on * 2 * (1 - assemblyProgress * 0.8);
                
                // å‡¹ã‚“ã éƒ¨åˆ†
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2 + tremor1, y2);
                ctx.lineTo(x3 + tremor2, y2);
                ctx.lineTo(x4, y1);
            }
            ctx.lineTo(jointCenterX + jointWidth / 2, jointCenterY + jointHeight / 2 + lowerOffsetY);
            ctx.stroke();
            
            // === çµ„ã¿åˆã‚ã›ã®éç¨‹ã‚’è¦–è¦šåŒ– ===
            
            // 1. çµ„ã¿åˆã‚ã›æ–¹å‘ã®çŸ¢å°ï¼ˆgpãŒä½ã„æ™‚=åˆ†é›¢çŠ¶æ…‹ï¼‰
            if (assemblyProgress < 0.7) {
                const arrowOpacity = (1 - assemblyProgress);
                ctx.lineWidth = 1 + (1 - assemblyProgress) * 1.5; // ã‚ˆã‚Šå¤ªã
                ctx.strokeStyle = `rgba(0, 0, 0, ${arrowOpacity})`;
                
                // ä¸Šã‹ã‚‰ä¸‹ã¸ã®çŸ¢å°ï¼ˆä¸Šå´ã®ãƒ”ãƒ¼ã‚¹ï¼‰- ã‚ˆã‚Šé•·ã
                const arrowY1 = jointCenterY - jointHeight / 2 - gapSize / 2 - 12;
                const arrowLen = 10 + gapSize * 0.2;
                ctx.beginPath();
                ctx.moveTo(jointCenterX, arrowY1);
                ctx.lineTo(jointCenterX, arrowY1 + arrowLen);
                ctx.stroke();
                // çŸ¢å°ã®å…ˆç«¯ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
                ctx.lineWidth = 1.2 + (1 - assemblyProgress) * 1.8;
                ctx.beginPath();
                ctx.moveTo(jointCenterX - 4, arrowY1 + arrowLen - 5);
                ctx.lineTo(jointCenterX, arrowY1 + arrowLen);
                ctx.lineTo(jointCenterX + 4, arrowY1 + arrowLen - 5);
                ctx.stroke();
                
                // ä¸‹ã‹ã‚‰ä¸Šã¸ã®çŸ¢å°ï¼ˆä¸‹å´ã®ãƒ”ãƒ¼ã‚¹ï¼‰
                const arrowY2 = jointCenterY + jointHeight / 2 + gapSize / 2 + 12;
                ctx.lineWidth = 1 + (1 - assemblyProgress) * 1.5;
                ctx.beginPath();
                ctx.moveTo(jointCenterX, arrowY2);
                ctx.lineTo(jointCenterX, arrowY2 - arrowLen);
                ctx.stroke();
                // çŸ¢å°ã®å…ˆç«¯
                ctx.lineWidth = 1.2 + (1 - assemblyProgress) * 1.8;
                ctx.beginPath();
                ctx.moveTo(jointCenterX - 4, arrowY2 - arrowLen + 5);
                ctx.lineTo(jointCenterX, arrowY2 - arrowLen);
                ctx.lineTo(jointCenterX + 4, arrowY2 - arrowLen + 5);
                ctx.stroke();
                
                ctx.strokeStyle = 'black'; // å…ƒã«æˆ»ã™
            }
            
            // 2. çµåˆéƒ¨ã®åœ§ç¸®æ³¢ç´‹ï¼ˆgpãŒé«˜ã„æ™‚=çµåˆçŠ¶æ…‹ï¼‰- ã‚ˆã‚Šå¼·åŒ–
            if (assemblyProgress > 0.3) {
                const compressionWaves = Math.floor(4 + assemblyProgress * 12); // 4ã€œ16æ³¢
                ctx.lineWidth = 0.2 + assemblyProgress * 0.4; // ã‚ˆã‚Šå¤ªã
                
                for (let i = 0; i < compressionWaves; i++) {
                    const t = i / compressionWaves;
                    const waveY = jointCenterY + (t - 0.5) * (jointHeight + lowerOffsetY - upperOffsetY - 8);
                    const waveAmplitude = (1 - Math.abs(t - 0.5) * 2) * assemblyProgress * 5; // æŒ¯å¹…ã‚’å¤§ãã
                    
                    ctx.beginPath();
                    for (let x = jointCenterX - jointWidth / 2 + 5; x <= jointCenterX + jointWidth / 2 - 5; x += 1.5) {
                        const xNorm = (x - (jointCenterX - jointWidth / 2 + 5)) / (jointWidth - 10);
                        const wave = Math.sin(xNorm * Math.PI * 3) * waveAmplitude; // æ³¢ã®æ•°ã‚‚å¢—åŠ 
                        const y = waveY + wave;
                        
                        if (x === jointCenterX - jointWidth / 2 + 5) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }
            
            // 3. å¿œåŠ›åˆ†æ•£ã®æ”¾å°„ç·šï¼ˆgpãŒé«˜ã„æ™‚ï¼‰- ã‚ˆã‚Šå¼·åŒ–
            if (assemblyProgress > 0.5) {
                const stressLines = Math.floor((assemblyProgress - 0.5) * 32); // 0ã€œ16æœ¬ï¼ˆã‚ˆã‚Šå¤šãï¼‰
                ctx.lineWidth = 0.3 + assemblyProgress * 0.5; // ã‚ˆã‚Šå¤ªã
                
                for (let i = 0; i < stressLines; i++) {
                    const angle = (i / stressLines) * Math.PI * 2;
                    const startRadius = jointWidth / 5;
                    const endRadius = jointWidth / 2; // ã‚ˆã‚Šé•·ã
                    
                    const x1 = jointCenterX + startRadius * Math.cos(angle);
                    const y1 = jointCenterY + startRadius * Math.sin(angle);
                    const x2 = jointCenterX + endRadius * Math.cos(angle);
                    const y2 = jointCenterY + endRadius * Math.sin(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
            
            // 4. æœ¨æç¹Šç¶­ã®é€£ç¶šæ€§ï¼ˆå®Œå…¨çµåˆæ™‚ï¼‰- ã‚ˆã‚Šå¼·åŒ–
            if (assemblyProgress > 0.7) {
                const fiberLines = Math.floor((assemblyProgress - 0.7) * 50); // 0ã€œ15æœ¬
                ctx.lineWidth = 0.25 + assemblyProgress * 0.35; // ã‚ˆã‚Šå¤ªã
                
                for (let i = 0; i < fiberLines; i++) {
                    const xPos = jointCenterX - jointWidth / 2 + 10 + (i / fiberLines) * (jointWidth - 20);
                    
                    ctx.beginPath();
                    // ä¸Šå´ã‹ã‚‰ä¸­å¿ƒã‚’é€šã£ã¦ä¸‹å´ã¸ï¼ˆç¹Šç¶­ã®é€£ç¶šæ€§ï¼‰
                    ctx.moveTo(xPos, jointCenterY - jointHeight / 2 + upperOffsetY + 5);
                    
                    // ä¸­å¿ƒéƒ¨ã§ã‚ãšã‹ã«æ³¢æ‰“ã¤ï¼ˆçµåˆéƒ¨ã®ç—•è·¡ï¼‰
                    const segments = 10;
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const y = jointCenterY - jointHeight / 2 + upperOffsetY + 5 + 
                                 t * (jointHeight + lowerOffsetY - upperOffsetY - 10);
                        const wave = Math.sin(t * Math.PI) * (1 - assemblyProgress) * 2 * on;
                        
                        ctx.lineTo(xPos + wave, y);
                    }
                    ctx.stroke();
                }
            }
            
            // 5. ç¶™æ‰‹ã®å´é¢ã®è©³ç´°ï¼ˆgpãŒé«˜ã„ã¨è¿½åŠ ï¼‰
            if (gp > 0.4) {
                ctx.lineWidth = 0.3 + gp * 0.4;
                
                // å·¦å³ã®å´é¢ç·šï¼ˆçµ„ã¿åˆã‚ã›ã«å¿œã˜ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
                ctx.beginPath();
                ctx.moveTo(jointCenterX - jointWidth / 2, jointCenterY - jointHeight / 2 + upperOffsetY);
                ctx.lineTo(jointCenterX - jointWidth / 2, jointCenterY + jointHeight / 2 + lowerOffsetY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(jointCenterX + jointWidth / 2, jointCenterY - jointHeight / 2 + upperOffsetY);
                ctx.lineTo(jointCenterX + jointWidth / 2, jointCenterY + jointHeight / 2 + lowerOffsetY);
                ctx.stroke();
            }
            
            // æ–­é¢ã®å¹´è¼ªï¼ˆç¶™æ‰‹ã«åˆ»ã¾ã‚ŒãŸæ™‚é–“ã®è¨˜æ†¶ï¼‰- gpã§å¯†åº¦ãŒå¤‰åŒ–
            const jointRings = Math.floor(3 + gp * 18 * weight); // 3ã€œ21
            ctx.lineWidth = 0.15 + gp * 0.3; // å¤ªã•ã‚‚å¤‰åŒ–
            
            // å¹´è¼ªã®ç¯„å›²ã‚’çµ„ã¿åˆã‚ã›çŠ¶æ…‹ã«å¿œã˜ã¦èª¿æ•´
            const ringStartY = jointCenterY - jointHeight / 2 + upperOffsetY + 10;
            const ringEndY = jointCenterY + jointHeight / 2 + lowerOffsetY - 10;
            const ringHeight = ringEndY - ringStartY;
            
            for (let i = 0; i < jointRings; i++) {
                const y = ringStartY + (i / jointRings) * ringHeight;
                
                ctx.beginPath();
                for (let x = jointCenterX - jointWidth / 2 + 10; x <= jointCenterX + jointWidth / 2 - 10; x += 2) {
                    const noise = perlin.get(x * 0.05, i * 0.4 + noiseOffset) * on * 4 * (1 + weight); // æŒ¯å¹…å¼·åŒ–
                    const finalY = y + noise;
                    
                    if (x === jointCenterX - jointWidth / 2 + 10) ctx.moveTo(x, finalY);
                    else ctx.lineTo(x, finalY);
                }
                ctx.stroke();
            }
            
            // ç²¾å¯†ãªå¯¸æ³•ç·šï¼ˆãƒ‡ã‚¸ã‚¿ãƒ«ã¨æ‰‹ã®èåˆã®è±¡å¾´ï¼‰- çµ„ã¿åˆã‚ã›å®Œæˆæ™‚ã«è¡¨ç¤º
            if (gp > 0.5 && assemblyProgress > 0.7) {
                ctx.lineWidth = 0.25 + assemblyProgress * 0.3;
                
                // æ°´å¹³å¯¸æ³•ç·šï¼ˆçµ„ã¿åˆã‚ã›çŠ¶æ…‹ã«å¿œã˜ã¦ä½ç½®èª¿æ•´ï¼‰
                const dimY = jointCenterY + jointHeight / 2 + lowerOffsetY + 12;
                ctx.beginPath();
                ctx.moveTo(jointCenterX - jointWidth / 2, dimY);
                ctx.lineTo(jointCenterX + jointWidth / 2, dimY);
                ctx.moveTo(jointCenterX - jointWidth / 2, dimY - 3);
                ctx.lineTo(jointCenterX - jointWidth / 2, dimY + 3);
                ctx.moveTo(jointCenterX + jointWidth / 2, dimY - 3);
                ctx.lineTo(jointCenterX + jointWidth / 2, dimY + 3);
                ctx.stroke();
                
                // å‚ç›´å¯¸æ³•ç·šï¼ˆçµ„ã¿åˆã‚ã›ã®é«˜ã•ï¼‰
                if (assemblyProgress > 0.9) {
                    const dimX = jointCenterX + jointWidth / 2 + 8;
                    ctx.beginPath();
                    ctx.moveTo(dimX, ringStartY);
                    ctx.lineTo(dimX, ringEndY);
                    ctx.moveTo(dimX - 2, ringStartY);
                    ctx.lineTo(dimX + 2, ringStartY);
                    ctx.moveTo(dimX - 2, ringEndY);
                    ctx.lineTo(dimX + 2, ringEndY);
                    ctx.stroke();
                }
            }
            
            // === å…¨ä½“ã®å¢ƒç•Œç·šï¼ˆ4ã¤ã®ã‚¾ãƒ¼ãƒ³ã‚’æ˜ç¢ºã«ï¼‰ ===
            ctx.lineWidth = 0.5;
            
            // ä¸­å¤®ã®åå­—
            ctx.beginPath();
            ctx.moveTo(center, 30);
            ctx.lineTo(center, 270);
            ctx.moveTo(30, center);
            ctx.lineTo(270, center);
            ctx.stroke();
        }
        
        // 7. ç«¯æ - æ•£ã‚‰ã°ã‚‹è¨˜æ†¶ã€é›†ã¾ã‚‹äºˆæ„Ÿï¼ˆçµ±åˆç‰ˆï¼‰
        function drawScrap(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(7);
            
            // === æ™‚é–“ã«ã‚ˆã‚‹ç‰©èªã®å¤‰åŒ–ï¼ˆå¼·èª¿ç‰ˆï¼‰ ===
            // weight < 1: åˆ‡æ–­ç›´å¾Œã€å¤–å´ã«æ•£ã‚‰ã°ã‚‹ï¼ˆéå»ï¼‰
            // weight = 1: æœ€å¤§æ•£ä¹±çŠ¶æ…‹ï¼ˆç¾åœ¨ï¼‰
            // weight > 1: ä¸­å¿ƒã¸ã®å¼•ãå¯„ã›ã®äºˆæ„Ÿï¼ˆæœªæ¥â†’Stage 8ã¸ï¼‰
            const scatterAmount = Math.sin((weight - 0.33) * Math.PI); // 0â†’1â†’0
            const pullToCenter = weight > 1 ? Math.pow((weight - 1) * 1.5, 1.5) : 0; // ã‚ˆã‚ŠæŒ‡æ•°çš„ãªå¼•åŠ›
            
            // ç«¯æã®æ•°ï¼ˆgpã§å¢—åŠ ï¼‰
            const numFragments = Math.floor(12 + gp * 45);
            const goldenAngle = 137.5 * (Math.PI / 180); // é»„é‡‘è§’
            
            for (let i = 0; i < numFragments; i++) {
                const t = i / numFragments;
                
                // === ãƒ•ã‚£ãƒœãƒŠãƒƒãƒé…ç½®ï¼ˆé»„é‡‘è§’ï¼‰- ã‚ˆã‚Šå¤–å´ã« ===
                const angle = i * goldenAngle;
                const baseRadius = 40 + t * 100; // ã‚ˆã‚Šå¤–å´ï¼ˆ30â†’40ã€90â†’100ï¼‰
                
                // æ™‚é–“ã«ã‚ˆã‚‹æ•£ã‚‰ã°ã‚Šï¼ˆã‚ˆã‚Šå¤§ããæ•£ã‚‰ã°ã‚‹ï¼‰
                const scatter = baseRadius * scatterAmount * (1.2 + seededRandom() * 0.6);
                const finalRadius = baseRadius * 0.2 + scatter; // ã‚ˆã‚Šæ•£ã‚‰ã°ã‚‹
                
                // æœªæ¥ã¸ã®å¼•ãå¯„ã›ï¼ˆStage 8ã¸ã®äºˆæ„Ÿï¼‰- å¼•åŠ›ã‚’å¼·åŒ–
                const pulledRadius = finalRadius * (1 - pullToCenter * 0.8);
                
                // æœ‰æ©Ÿçš„ãªæºã‚‰ã
                const noise = perlin.get(i * 0.3, noiseOffset) * on * 6;
                
                const x = center + (pulledRadius + noise) * Math.cos(angle);
                const y = center + (pulledRadius + noise) * Math.sin(angle);
                
                // === è½ä¸‹ã®è»Œè·¡ï¼ˆåˆ‡æ–­ç‚¹ã‹ã‚‰ã®è»Œè·¡ï¼‰ ===
                if (scatterAmount > 0.2) {
                    const originX = center + baseRadius * 0.2 * Math.cos(angle);
                    const originY = center + baseRadius * 0.2 * Math.sin(angle);
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.1 + scatterAmount * 0.15})`;
                    ctx.lineWidth = 0.15;
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    
                    // ãƒ™ã‚¸ã‚§æ›²ç·šã§è‡ªç„¶ãªè»Œè·¡
                    const cpx = (originX + x) / 2 + (seededRandom() - 0.5) * 30 * on;
                    const cpy = (originY + y) / 2 + (seededRandom() - 0.5) * 30 * on;
                    ctx.quadraticCurveTo(cpx, cpy, x, y);
                    ctx.stroke();
                    ctx.strokeStyle = 'black';
                }
                
                // === ç«¯æã®å½¢çŠ¶ã¨ã‚µã‚¤ã‚ºï¼ˆå¤šæ§˜ãªãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ ===
                // ç¢ºç‡çš„ã«å½¢çŠ¶ã‚’é¸æŠï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã¯10%ã®ã¿ï¼‰
                const rand = seededRandom();
                let fragmentType;
                if (rand < 0.1) {
                    fragmentType = 1; // ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆ10%ï¼‰
                } else if (rand < 0.35) {
                    fragmentType = 0; // å††å½¢ï¼ˆ25%ï¼‰
                } else if (rand < 0.65) {
                    fragmentType = 3; // æœ‰æ©Ÿçš„ï¼ˆ30%ï¼‰
                } else {
                    fragmentType = 4; // ä¸è¦å‰‡ãªç ´ç‰‡ï¼ˆ35%ï¼‰
                }
                
                const size = (6 + seededRandom() * 20 + t * 12) * (0.5 + gp * 0.5);
                const rotationAngle = angle + seededRandom() * Math.PI;
                
                // é»„é‡‘æ¯”
                const phi = (1 + Math.sqrt(5)) / 2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotationAngle);
                
                // === å¹´è¼ªã®è©³ç´°è¡¨ç¾ ===
                const rings = Math.floor(2 + gp * 7);
                
                for (let j = 0; j < rings; j++) {
                    const ringT = j / rings;
                    const r = (j + 1) * (size / (rings * 1.8));
                    
                    // é«„ã‹ã‚‰ã®è·é›¢ã§æ¿ƒæ·¡ï¼ˆä¸­å¿ƒ=è‹¥ã„=è–„ã„ã€å¤–å´=å¤ã„=æ¿ƒã„ï¼‰
                    const density = 0.3 + ringT * 0.5;
                    
                    // æ—©æã¨æ™©æã®è¡¨ç¾ï¼ˆäº¤äº’ã«å¤ªã•ã‚’å¤‰ãˆã‚‹ï¼‰
                    const isLatewood = j % 2 === 1;
                    ctx.lineWidth = isLatewood ? 0.5 + gp * 0.3 : 0.25 + gp * 0.15;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${density})`;
                    
                    ctx.beginPath();
                    
                    // å½¢çŠ¶ã«ã‚ˆã‚‹æç”»
                    if (fragmentType === 0) {
                        // å††å½¢ã®æ–­é¢ï¼ˆä¸¸å¤ªï¼‰
                        const segments = 20;
                        for (let k = 0; k <= segments; k++) {
                            const a = (k / segments) * Math.PI * 2;
                            const noise = perlin.get(k * 0.5 + i, j * 0.3) * on * 6;
                            const px = (r + noise) * Math.cos(a);
                            const py = (r + noise) * Math.sin(a);
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                    } else if (fragmentType === 1) {
                        // é»„é‡‘æ¯”ã®çŸ©å½¢ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆç¸¦é•·ï¼‰
                        const w = r * 2;
                        const h = w * phi;
                        const grainNoise = perlin.get(i * 0.3, j * 0.2) * on * 6;
                        ctx.rect(-w / 2 + grainNoise, -h / 2, w, h);
                    } else if (fragmentType === 2) {
                        // é»„é‡‘æ¯”ã®çŸ©å½¢ã‚¿ã‚¤ãƒ«ï¼ˆæ¨ªé•·ï¼‰
                        const h = r * 2;
                        const w = h * phi;
                        const grainNoise = perlin.get(i * 0.3, j * 0.2) * on * 6;
                        ctx.rect(-w / 2, -h / 2 + grainNoise, w, h);
                    } else if (fragmentType === 3) {
                        // æœ‰æ©Ÿçš„ãªå½¢çŠ¶ï¼ˆPerlin noiseãƒ™ãƒ¼ã‚¹ï¼‰
                        const segments = 16;
                        for (let k = 0; k <= segments; k++) {
                            const a = (k / segments) * Math.PI * 2;
                            const organicNoise = perlin.get(
                                Math.cos(a) * 0.5 + i * 0.2, 
                                Math.sin(a) * 0.5 + j * 0.3
                            ) * on * 8;
                            const radiusVar = r * (1 + organicNoise / r);
                            const px = radiusVar * Math.cos(a);
                            const py = radiusVar * Math.sin(a);
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                    } else {
                        // ä¸è¦å‰‡ãªç ´ç‰‡ï¼ˆå‰²ã‚ŒãŸå½¢ï¼‰
                        const segments = 8;
                        for (let k = 0; k <= segments; k++) {
                            const a = (k / segments) * Math.PI * 1.6; // ç´„3/4å††
                            const noise = perlin.get(k * 0.5 + i, j * 0.3) * on * 6;
                            const radiusVar = r + noise + (k % 2) * 3;
                            const px = radiusVar * Math.cos(a);
                            const py = radiusVar * Math.sin(a);
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                    }
                    ctx.stroke();
                }
                
                // === ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«æ–­ç‰‡ï¼ˆå¤§ããªç«¯æã®å‘¨ã‚Šã«å°ã•ãªç ´ç‰‡ï¼‰ ===
                if (size > 15 && gp > 0.4) {
                    const numSubFragments = Math.floor(2 + gp * 4);
                    for (let sub = 0; sub < numSubFragments; sub++) {
                        const subAngle = (sub / numSubFragments) * Math.PI * 2;
                        const subDist = size * 0.7 + seededRandom() * size * 0.3;
                        const subX = subDist * Math.cos(subAngle);
                        const subY = subDist * Math.sin(subAngle);
                        const subSize = size * (0.15 + seededRandom() * 0.15);
                        
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.4 + seededRandom() * 0.3})`;
                        ctx.lineWidth = 0.3;
                        ctx.beginPath();
                        
                        const subSegments = 6;
                        for (let k = 0; k <= subSegments; k++) {
                            const a = (k / subSegments) * Math.PI * 2;
                            const px = subX + subSize * Math.cos(a);
                            const py = subY + subSize * Math.sin(a);
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            ctx.strokeStyle = 'black'; // ãƒªã‚»ãƒƒãƒˆ
            
            // === ç«¯æã®ä½ç½®ã‚’é…åˆ—ã«ä¿å­˜ï¼ˆå¾Œã§ä½¿ç”¨ï¼‰ ===
            const fragmentPositions = [];
            for (let i = 0; i < numFragments; i++) {
                const t = i / numFragments;
                const angle = i * goldenAngle;
                const baseRadius = 30 + t * 90;
                const scatter = baseRadius * scatterAmount * (0.8 + seededRandom() * 0.4);
                const finalRadius = baseRadius * 0.3 + scatter;
                const pulledRadius = finalRadius * (1 - pullToCenter * 0.6);
                const noise = perlin.get(i * 0.3, noiseOffset) * on * 6;
                
                fragmentPositions.push({
                    x: center + (pulledRadius + noise) * Math.cos(angle),
                    y: center + (pulledRadius + noise) * Math.sin(angle)
                });
            }
            
            // === ç«¯æåŒå£«ã®æœ‰æ©Ÿçš„ãªã¤ãªãŒã‚Šï¼ˆå‰µé€ çš„æ´»ç”¨ï¼‰- å¼·èª¿ç‰ˆ ===
            if (gp > 0.2) { // é–¾å€¤ã‚’ä¸‹ã’ã¦æ—©ãè¡¨ç¤º
                // è¿‘ã„ç«¯æåŒå£«ã‚’çµåˆã—ã¦æ–°ã—ã„ä¾¡å€¤ã‚’å‰µé€ 
                const connectionThreshold = 45 + (1 - gp) * 35; // ã‚ˆã‚Šåºƒã„ç¯„å›²ã§ç¹‹ãŒã‚‹
                const connections = []; // çµåˆãƒšã‚¢ã‚’è¨˜éŒ²
                
                for (let i = 0; i < fragmentPositions.length; i++) {
                    const p1 = fragmentPositions[i];
                    
                    for (let j = i + 1; j < fragmentPositions.length; j++) {
                        const p2 = fragmentPositions[j];
                        const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                        
                        if (dist < connectionThreshold) {
                            connections.push({ p1, p2, dist });
                        }
                    }
                }
                
                // === çµåˆç·šã®æç”»ï¼ˆç«¯ææ´»ç”¨ã®ã¤ãªãŒã‚Šï¼‰- ã‚ˆã‚Šå¤ªãæ¿ƒã ===
                for (const conn of connections) {
                    const { p1, p2, dist } = conn;
                    
                    // è·é›¢ãŒè¿‘ã„ã»ã©å¼·ã„çµåˆ
                    const strength = 1 - dist / connectionThreshold;
                    const opacity = 0.2 + strength * (0.4 + gp * 0.4); // ã‚ˆã‚Šæ¿ƒã
                    const lineWidth = 0.6 + strength * (1.2 + gp * 1.8); // ã‚ˆã‚Šå¤ªã
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    
                    // æœ‰æ©Ÿçš„ãªæ›²ç·šã§çµåˆ
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    const curveOffset = perlin.get(midX * 0.02, midY * 0.02) * on * 6;
                    const perpX = -(p2.y - p1.y) / dist;
                    const perpY = (p2.x - p1.x) / dist;
                    
                    ctx.quadraticCurveTo(
                        midX + perpX * curveOffset,
                        midY + perpY * curveOffset,
                        p2.x, p2.y
                    );
                    ctx.stroke();
                }
                
                // === ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ï¼ˆç«¯æé›†åˆä½“ï¼‰ã®è¦–è¦šåŒ– ===
                // å¼·ãçµåˆã•ã‚ŒãŸç«¯æç¾¤ã‚’è¦‹ã¤ã‘ã‚‹
                const clusters = [];
                const visited = new Set();
                
                for (let i = 0; i < fragmentPositions.length; i++) {
                    if (visited.has(i)) continue;
                    
                    const cluster = [i];
                    visited.add(i);
                    
                    // æ·±ã•å„ªå…ˆæ¢ç´¢ã§ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã‚’æ§‹ç¯‰
                    const stack = [i];
                    while (stack.length > 0) {
                        const current = stack.pop();
                        const p1 = fragmentPositions[current];
                        
                        for (let j = 0; j < fragmentPositions.length; j++) {
                            if (visited.has(j)) continue;
                            
                            const p2 = fragmentPositions[j];
                            const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                            
                            if (dist < connectionThreshold * 0.8) {
                                cluster.push(j);
                                visited.add(j);
                                stack.push(j);
                            }
                        }
                    }
                    
                    if (cluster.length >= 2) {
                        clusters.push(cluster);
                    }
                }
                
                // === å„ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã«ã€Œä»˜åŠ ä¾¡å€¤ã€ã‚’è¡¨ç¾ ===
                for (const cluster of clusters) {
                    if (cluster.length < 2) continue;
                    
                    // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã®ä¸­å¿ƒã‚’è¨ˆç®—
                    let cx = 0, cy = 0;
                    for (const idx of cluster) {
                        cx += fragmentPositions[idx].x;
                        cy += fragmentPositions[idx].y;
                    }
                    cx /= cluster.length;
                    cy /= cluster.length;
                    
                    // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                    let maxDist = 0;
                    for (const idx of cluster) {
                        const p = fragmentPositions[idx];
                        const dist = Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);
                        maxDist = Math.max(maxDist, dist);
                    }
                    
                    // === ä»˜åŠ ä¾¡å€¤ã®è¡¨ç¾ï¼ˆå¹¾ä½•å­¦çš„ãªç¾ã€æ©Ÿèƒ½çš„ãªæ§‹é€ ï¼‰ ===
                    const phi = (1 + Math.sqrt(5)) / 2;
                    const valueSize = maxDist * 0.6;
                    
                    ctx.save();
                    ctx.translate(cx, cy);
                    
                    // 1. é»„é‡‘æ¯”ã®èºæ—‹ï¼ˆãƒ‡ã‚¶ã‚¤ãƒ³çš„ä¾¡å€¤ï¼‰- ã‚ˆã‚Šç›®ç«‹ãŸã›ã‚‹
                    if (cluster.length >= 3 && gp > 0.4) { // é–¾å€¤ã‚’ä¸‹ã’ã‚‹
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.2 + gp * 0.25})`;
                        ctx.lineWidth = 0.8 + gp * 1.2;
                        ctx.beginPath();
                        
                        const spiralSegments = 30;
                        for (let i = 0; i <= spiralSegments; i++) {
                            const t = i / spiralSegments;
                            const angle = t * Math.PI * 3;
                            const r = valueSize * t / phi;
                            const px = r * Math.cos(angle);
                            const py = r * Math.sin(angle);
                            
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }
                    
                    // 2. æ”¾å°„çŠ¶ã®æ§‹é€ ç·šï¼ˆæ©Ÿèƒ½çš„ä¾¡å€¤ãƒ»å¼·åº¦ï¼‰- ã‚ˆã‚Šå¤ªã
                    if (cluster.length >= 2) {
                        const numRays = cluster.length;
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.15 + gp * 0.2})`;
                        ctx.lineWidth = 0.5 + gp * 0.8;
                        
                        for (let i = 0; i < numRays; i++) {
                            const angle = (i / numRays) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(valueSize * Math.cos(angle), valueSize * Math.sin(angle));
                            ctx.stroke();
                        }
                    }
                    
                    // 3. å€‹ã€…äººã®ä¾¡å€¤ï¼ˆãƒ¦ãƒ‹ãƒ¼ã‚¯ãªæ¨¡æ§˜ï¼‰
                    if (cluster.length >= 4 && gp > 0.6) {
                        // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼IDã«åŸºã¥ããƒ¦ãƒ‹ãƒ¼ã‚¯ãªæ¨¡æ§˜
                        const seed = cluster.reduce((a, b) => a + b, 0);
                        const numLines = 3 + (seed % 6);
                        
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.08 + gp * 0.12})`;
                        ctx.lineWidth = 0.4;
                        
                        for (let i = 0; i < numLines; i++) {
                            const t = i / numLines;
                            const angle = t * Math.PI * 2 + seed * 0.1;
                            const r1 = valueSize * 0.3;
                            const r2 = valueSize * 0.8;
                            const offset = Math.sin(seed + i) * valueSize * 0.2;
                            
                            ctx.beginPath();
                            ctx.moveTo(r1 * Math.cos(angle), r1 * Math.sin(angle) + offset);
                            ctx.lineTo(r2 * Math.cos(angle), r2 * Math.sin(angle) - offset);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === ãƒœãƒ­ãƒã‚¤å›³é¢¨ã®é ˜åŸŸç·šï¼ˆå¯èƒ½æ€§ã®å¢ƒç•Œï¼‰- ã‚ˆã‚Šè¡¨ç¤ºã—ã‚„ã™ã ===
            if (gp > 0.15 || on > 0.15) { // é–¾å€¤ã‚’ä¸‹ã’ã¦æ—©ãè¡¨ç¤º
                // ã‚ˆã‚Šå¤šãã®ç«¯æé–“ã®æ¥ç¶šç·šã‚’æãï¼ˆãƒœãƒ­ãƒã‚¤é¢¨ã®ç¶²ç›®ï¼‰
                const maxConnections = Math.floor(3 + gp * 5); // å„ç«¯æã‹ã‚‰3-8æœ¬ã®æ¥ç¶š
                
                for (let i = 0; i < fragmentPositions.length; i++) {
                    const p1 = fragmentPositions[i];
                    
                    // è·é›¢ã®è¿‘ã„ç«¯æã‚’è¦‹ã¤ã‘ã¦æ¥ç¶š
                    const distances = [];
                    for (let j = 0; j < fragmentPositions.length; j++) {
                        if (i !== j) {
                            const p2 = fragmentPositions[j];
                            const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                            distances.push({ index: j, dist: dist, pos: p2 });
                        }
                    }
                    
                    // è·é›¢ã§ã‚½ãƒ¼ãƒˆ
                    distances.sort((a, b) => a.dist - b.dist);
                    
                    // è¿‘ã„é †ã«æ¥ç¶šç·šã‚’æã
                    const numConnections = Math.min(maxConnections, distances.length);
                    for (let k = 0; k < numConnections; k++) {
                        const p2 = distances[k].pos;
                        const dist = distances[k].dist;
                        
                        // ä¸­ç‚¹
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        
                        // è·é›¢ã«å¿œã˜ã¦é€æ˜åº¦ã‚’å¤‰åŒ–
                        const opacity = Math.max(0, 0.2 - dist / 600) + on * 0.15;
                        ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                        ctx.lineWidth = 0.15 + gp * 0.2;
                        
                        // å‚ç›´äºŒç­‰åˆ†ç·šï¼ˆãƒœãƒ­ãƒã‚¤å¢ƒç•Œï¼‰
                        const perpLength = 12 + gp * 20;
                        ctx.beginPath();
                        ctx.moveTo(midX - dy * perpLength / 100, midY + dx * perpLength / 100);
                        ctx.lineTo(midX + dy * perpLength / 100, midY - dx * perpLength / 100);
                        ctx.stroke();
                    }
                }
                
                // ãƒœãƒ­ãƒã‚¤ã‚»ãƒ«çš„ãªå¤šè§’å½¢ã®æç”»ï¼ˆgpãŒé«˜ã„æ™‚ï¼‰
                if (gp > 0.5) {
                    for (let i = 0; i < fragmentPositions.length; i++) {
                        const p = fragmentPositions[i];
                        
                        // ã“ã®ç«¯æã‚’ä¸­å¿ƒã¨ã—ãŸé ˜åŸŸã‚’æã
                        const cellSegments = 8;
                        const cellRadius = 15 + gp * 25;
                        
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.08 + gp * 0.12})`;
                        ctx.lineWidth = 0.2;
                        ctx.beginPath();
                        
                        for (let j = 0; j <= cellSegments; j++) {
                            const angle = (j / cellSegments) * Math.PI * 2;
                            const noise = perlin.get(
                                p.x * 0.01 + Math.cos(angle), 
                                p.y * 0.01 + Math.sin(angle)
                            ) * on * 8;
                            const r = cellRadius + noise;
                            const px = p.x + r * Math.cos(angle);
                            const py = p.y + r * Math.sin(angle);
                            
                            if (j === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === å¼•åŠ›å ´ã®è¦–è¦šåŒ–ï¼ˆæœªæ¥ã¸ã®å¼•ãå¯„ã›ï¼‰ ===
            if (pullToCenter > 0.1) {
                // ä¸­å¿ƒã‹ã‚‰æ”¾å°„çŠ¶ã«å¼•åŠ›ç·šã‚’æã
                const numForceLines = Math.floor(8 + gp * 16);
                
                for (let i = 0; i < numForceLines; i++) {
                    const angle = (i / numForceLines) * Math.PI * 2;
                    const startRadius = 20;
                    const endRadius = 110;
                    
                    // å¼•åŠ›ã®å¼·ã•ã§é€æ˜åº¦ã‚’å¤‰åŒ–
                    ctx.strokeStyle = `rgba(0, 0, 0, ${pullToCenter * (0.15 + gp * 0.15)})`;
                    ctx.lineWidth = 0.3 + pullToCenter * 0.5;
                    ctx.beginPath();
                    
                    // å¼•åŠ›ç·šã‚’æ³¢æ‰“ãŸã›ã‚‹
                    const segments = 12;
                    for (let j = 0; j <= segments; j++) {
                        const t = j / segments;
                        const r = startRadius + (endRadius - startRadius) * t;
                        
                        // å¼•åŠ›ã«ã‚ˆã‚‹åæŸã®æ³¢
                        const wave = Math.sin(t * Math.PI * 3 + weight * 2) * on * 5 * (1 - t);
                        const finalR = r + wave;
                        
                        const px = center + finalR * Math.cos(angle);
                        const py = center + finalR * Math.sin(angle);
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // ä¸­å¿ƒã¸ã®åæŸç‚¹ï¼ˆæ¸¦ï¼‰
                const vortexRings = Math.floor(3 + pullToCenter * 8);
                for (let i = 0; i < vortexRings; i++) {
                    const r = 5 + i * 3;
                    const opacity = pullToCenter * (1 - i / vortexRings) * 0.4;
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                    ctx.lineWidth = 0.4 + pullToCenter * 0.8;
                    ctx.beginPath();
                    
                    const segments = 24;
                    for (let j = 0; j <= segments; j++) {
                        const t = j / segments;
                        const a = t * Math.PI * 2 + weight * 2 + i * 0.3;
                        const spiralR = r * (1 + Math.sin(t * Math.PI * 2) * 0.2 * on);
                        
                        const px = center + spiralR * Math.cos(a);
                        const py = center + spiralR * Math.sin(a);
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === æœ¨å±‘ã®èˆã„ï¼ˆå°ã•ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰ ===
            const numChips = Math.floor(20 + gp * 40);
            
            for (let i = 0; i < numChips; i++) {
                const chipAngle = i * goldenAngle * 2.5;
                const chipRadius = 20 + (i / numChips) * 110;
                const chipNoise = perlin.get(i * 0.5, noiseOffset * 2) * on * 25;
                
                // æ™‚é–“ã§æ¼‚ã†å‹•ã
                const drift = Math.sin(chipAngle + weight * 2) * 8 * on;
                
                // å¼•åŠ›å ´ã®å½±éŸ¿
                const pullEffect = pullToCenter > 0 ? (1 - chipRadius / 130) * pullToCenter * 20 : 0;
                
                const chipX = center + (chipRadius + chipNoise + drift - pullEffect) * Math.cos(chipAngle);
                const chipY = center + (chipRadius + chipNoise + drift - pullEffect) * Math.sin(chipAngle);
                
                const chipSize = 0.5 + seededRandom() * (1 + gp * 1.5);
                
                // å°ã•ãªç·šåˆ†ã¨ã—ã¦æç”»
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.2 + seededRandom() * 0.3})`;
                ctx.lineWidth = chipSize;
                ctx.beginPath();
                const chipLen = 1 + seededRandom() * 3;
                ctx.moveTo(chipX, chipY);
                ctx.lineTo(chipX + chipLen * Math.cos(chipAngle), chipY + chipLen * Math.sin(chipAngle));
                ctx.stroke();
            }
            
            ctx.strokeStyle = 'black'; // ãƒªã‚»ãƒƒãƒˆ
        }
        
        // 8. å†ç”Ÿ - å¾ªç’°ã®å®Œçµï¼ˆåœŸã¸é‚„ã‚Šã€æ–°ãŸãªç”Ÿå‘½ã¸ï¼‰çµ±åˆç‰ˆ
        function drawRegeneration(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(8);
            
            // === æ™‚é–“ã«ã‚ˆã‚‹ç‰©èªã®å¤‰åŒ– ===
            // éå»ã§ã‚‚è±Šã‹ãªçŠ¶æ…‹ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã€æ™‚é–“ã‚’å¤§èƒ†ã«ãƒªãƒãƒƒãƒ—
            // weight=0ã§æ—¢ã«åŠåˆ†åˆ†è§£ãŒé€²ã‚“ã§ã„ã‚‹çŠ¶æ…‹ã‹ã‚‰é–‹å§‹
            const timeAdjusted = weight < 1 ? 0.5 + weight * 0.5 : weight;
            
            // timeAdjusted: 0.5ã€œ1.0ï¼ˆéå»â†’ç¾åœ¨ï¼‰: åˆ†è§£ã¨å†ç”Ÿã®é–‹å§‹
            // timeAdjusted: 1.0ã€œ2.0ï¼ˆç¾åœ¨â†’æœªæ¥ï¼‰: å®Œå…¨ãªå†ç”Ÿã¸
            const decompositionProgress = Math.min(1, timeAdjusted); // 0.5ã€œ1
            const regenerationProgress = Math.max(0, (timeAdjusted - 0.7) * 2); // æ—©ã‚ã«å†ç”Ÿé–‹å§‹
            
            const goldenAngle = 137.5 * (Math.PI / 180);
            const phi = (1 + Math.sqrt(5)) / 2;
            
            // === æ–­ç‰‡ã®é…ç½®ï¼ˆåˆ†è§£ã—ã¦ã„ãç«¯æï¼‰- æœ€åˆã‹ã‚‰å¯†é›†ã€ã‚ˆã‚Šå¤šã ===
            const numFragments = Math.floor(35 + gp * 80); // ã‚ˆã‚Šå¤šã
            const spiralTurns = 4 + gp * 6; // ã‚ˆã‚Šå¤šãã®å›è»¢
            
            for (let i = 0; i < numFragments; i++) {
                const t = i / numFragments;
                
                // é»„é‡‘è§’ã«ã‚ˆã‚‹èºæ—‹é…ç½®ï¼ˆæœ€åˆã‹ã‚‰ä¸­å¿ƒã«è¿‘ã„ï¼‰
                const angle = t * spiralTurns * Math.PI * 2;
                const maxDist = 70 * Math.max(0.2, 1 - decompositionProgress * 0.8); // ã‚ˆã‚Šå°ã•ã
                const startDist = maxDist * (0.5 + t * 0.5); // ã‚ˆã‚Šä¸­å¿ƒã«
                
                const noise = perlin.get(i * 0.3, angle * 0.2 + noiseOffset) * on * 6;
                const startX = center + (startDist + noise) * Math.cos(angle);
                const startY = center + (startDist + noise) * Math.sin(angle);
                
                // === æ–­ç‰‡ï¼ˆåˆ†è§£ã§å°ã•ããªã‚‹ï¼‰ ===
                const fragmentSize = (2 + gp * 7) * (1 - decompositionProgress * 0.6);
                const fragmentRings = Math.floor(2 + gp * 3);
                
                // é€æ˜åº¦ï¼ˆåˆ†è§£ã§è–„ããªã‚‹ï¼‰
                const fragmentOpacity = 0.4 + (1 - decompositionProgress) * 0.6;
                
                ctx.save();
                ctx.translate(startX, startY);
                ctx.rotate(angle);
                
                for (let j = 0; j < fragmentRings; j++) {
                    const r = (j + 1) * (fragmentSize / fragmentRings);
                    ctx.strokeStyle = `rgba(0, 0, 0, ${fragmentOpacity})`;
                    ctx.lineWidth = 0.3 + (1 - decompositionProgress) * 0.3;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
                
                // === ä¸­å¿ƒã¸ã®é¤Šåˆ†ã®æµã‚Œï¼ˆæœ‰æ©Ÿçš„ãªæ›²ç·šï¼‰- ã‚ˆã‚Šæ¿ƒãã€å¤ªãã€å¸¸ã«è¡¨ç¤º ===
                if (decompositionProgress > 0) { // å¸¸ã«è¡¨ç¤º
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.25 + decompositionProgress * 0.45})`; // ã‚ˆã‚Šæ¿ƒã
                    ctx.lineWidth = 0.4 + decompositionProgress * (0.9 + gp * 1.5); // ã‚ˆã‚Šå¤ªã
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    const flowSegments = 15;
                    for (let j = 1; j <= flowSegments; j++) {
                        const ft = j / flowSegments;
                        const currentAngle = angle - ft * spiralTurns * Math.PI * 0.4;
                        const currentDist = startDist * (1 - ft * decompositionProgress);
                        const flowNoise = perlin.get(i * 0.2 + ft * 4, currentAngle + noiseOffset) * on * 8;
                        
                        const x = center + (currentDist + flowNoise) * Math.cos(currentAngle);
                        const y = center + (currentDist + flowNoise) * Math.sin(currentAngle);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = 'black'; // ãƒªã‚»ãƒƒãƒˆ
            
            // === åœŸå£Œå¾®ç”Ÿç‰©ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆåˆ†è§£ã‚’ä¿ƒé€²ï¼‰- ã‚ˆã‚Šå¤šãã€å¸¸ã«è¡¨ç¤º ===
            if (decompositionProgress > 0) { // å¸¸ã«è¡¨ç¤º
                const numMicrobes = Math.floor(80 + gp * 150 * decompositionProgress); // ã‚ˆã‚Šå¤šã
                
                for (let i = 0; i < numMicrobes; i++) {
                    const angle = i * goldenAngle * 1.5;
                    const radius = 20 + (i / numMicrobes) * 90 * (1 - decompositionProgress * 0.3);
                    const microbeNoise = perlin.get(i * 0.4, noiseOffset * 3) * on * 20;
                    
                    const drift = Math.sin(angle + weight * 3) * 10 * on;
                    
                    const microbeX = center + (radius + microbeNoise + drift) * Math.cos(angle);
                    const microbeY = center + (radius + microbeNoise + drift) * Math.sin(angle);
                    
                    const microbeSize = 0.3 + seededRandom() * (1 + gp * 1.2) * decompositionProgress;
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 + seededRandom() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(microbeX, microbeY, microbeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = 'black';
            }
            
            // === èŒç³¸ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼ˆL-systemçš„ãªåºƒãŒã‚Šï¼‰- ã‚ˆã‚Šå¤ªãã€é•·ãã€å¸¸ã«è¡¨ç¤º ===
            if (decompositionProgress > 0 && gp > 0) { // å¸¸ã«è¡¨ç¤ºã€gpé–¾å€¤ã‚‚æ’¤å»ƒ
                const numHyphae = Math.floor(15 + gp * 35); // ã‚ˆã‚Šå¤šã
                
                for (let i = 0; i < numHyphae; i++) {
                    const startAngle = (i / numHyphae) * Math.PI * 2;
                    const startRadius = 20 + seededRandom() * 25;
                    
                    let x = center + startRadius * Math.cos(startAngle);
                    let y = center + startRadius * Math.sin(startAngle);
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.2 + decompositionProgress * 0.4})`; // ã‚ˆã‚Šæ¿ƒã
                    ctx.lineWidth = 0.3 + gp * 0.5; // ã‚ˆã‚Šå¤ªã
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    
                    // èŒç³¸ã®æˆé•·
                    let currentAngle = startAngle;
                    const segments = Math.floor(8 + gp * 12);
                    
                    for (let j = 0; j < segments; j++) {
                        const segmentLength = 4 + seededRandom() * 8;
                        const angleChange = (seededRandom() - 0.5) * 0.8;
                        currentAngle += angleChange;
                        
                        const noise = perlin.get(x * 0.05, y * 0.05) * on * 8;
                        x += segmentLength * Math.cos(currentAngle) + noise;
                        y += segmentLength * Math.sin(currentAngle) + noise;
                        
                        ctx.lineTo(x, y);
                        
                        // åˆ†å²ï¼ˆç¢ºç‡çš„ï¼‰
                        if (seededRandom() < 0.2 && j < segments - 2) {
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === è¤‡æ•°ã®é»„é‡‘æ¯”èºæ—‹ï¼ˆå¾ªç’°ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰- å¸¸ã«è¡¨ç¤º ===
            if (decompositionProgress > 0) { // å¸¸ã«è¡¨ç¤º
                const numSpirals = Math.floor(3 + gp * 6); // ã‚ˆã‚Šå¤šã
                
                for (let s = 0; s < numSpirals; s++) {
                    const spiralOffset = (s / numSpirals) * Math.PI * 2;
                    const spiralOpacity = 0.08 + decompositionProgress * (0.1 + gp * 0.15); // ãƒ™ãƒ¼ã‚¹é€æ˜åº¦è¿½åŠ 
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${spiralOpacity})`;
                    ctx.lineWidth = 0.4 + gp * 0.8;
                    ctx.beginPath();
                    
                    const spiralSegments = 50;
                    for (let i = 0; i <= spiralSegments; i++) {
                        const t = i / spiralSegments;
                        const angle = spiralOffset + t * Math.PI * 4;
                        const r = t * 60 * decompositionProgress / phi;
                        
                        const px = center + r * Math.cos(angle);
                        const py = center + r * Math.sin(angle);
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === ä¸­å¿ƒã®æ–°ã—ã„ç¨®å­ï¼ˆStage 1ã¸å¾ªç’°ï¼‰===
            const seedRadius = 8 + gp * 22 + regenerationProgress * 15; // Stage 1ã¨åŒæ§˜ã®æˆé•·
            const seedOpacityBase = 0.6 + decompositionProgress * 0.3 + regenerationProgress * 0.1;
            
            // å¤–å´ã®å††ï¼ˆç¨®å­ã®å¤–æ®»ï¼‰
            ctx.strokeStyle = `rgba(0, 0, 0, ${seedOpacityBase})`;
            ctx.lineWidth = 1.5 + gp * 2.5;
            ctx.beginPath();
            ctx.arc(center, center, seedRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // === Phyllotaxisï¼ˆè‘‰åºï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³ - Stage 1ã®ç¨®å­ã¨åŒã˜ ===
            const phyllotaxisPoints = Math.floor(40 + gp * 80 + regenerationProgress * 50); // æˆé•·ã§å¢—åŠ 
            const phyllotaxisScale = seedRadius * 0.9 / Math.sqrt(phyllotaxisPoints);
            const phylloGoldenAngle = 137.5 * (Math.PI / 180);
            
            const phylloCoords = [];
            
            // è‘‰åºã®ç‚¹ã‚’è¨ˆç®—
            for (let i = 1; i <= phyllotaxisPoints; i++) {
                const angle = i * phylloGoldenAngle;
                const radius = phyllotaxisScale * Math.sqrt(i);
                
                if (radius < seedRadius * 0.9) {
                    const px = center + radius * Math.cos(angle);
                    const py = center + radius * Math.sin(angle);
                    phylloCoords.push({ x: px, y: py, index: i });
                }
            }
            
            // è‘‰åºã®ç·šï¼ˆæˆé•·ã®è»Œè·¡ï¼‰
            ctx.strokeStyle = `rgba(0, 0, 0, ${seedOpacityBase * 0.6})`;
            ctx.lineWidth = 0.25 + gp * 0.35 + regenerationProgress * 0.2;
            ctx.beginPath();
            
            for (let i = 0; i < phylloCoords.length - 1; i++) {
                const current = phylloCoords[i];
                const next = phylloCoords[i + 1];
                
                if (i === 0) ctx.moveTo(current.x, current.y);
                ctx.lineTo(next.x, next.y);
            }
            ctx.stroke();
            
            // è‘‰åºã®ç‚¹ï¼ˆç´°èƒ/å°†æ¥ã®è‘‰èŠ½ï¼‰
            ctx.fillStyle = `rgba(0, 0, 0, ${seedOpacityBase})`;
            const baseDotRadius = 0.4 + gp * 0.8 + regenerationProgress * 0.4;
            
            for (let i = 0; i < phylloCoords.length; i++) {
                const point = phylloCoords[i];
                const t = i / phylloCoords.length;
                
                // ä¸­å¿ƒã»ã©å¤§ããï¼ˆå¤ã„ç´°èƒï¼‰ã€å¤–å´ã»ã©å°ã•ãï¼ˆæ–°ã—ã„ç´°èƒï¼‰
                const cellSize = baseDotRadius * (1.4 - t * 0.6);
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, cellSize, 0, Math.PI * 2);
                ctx.fill();
                
                // æˆé•·ã®åŠ›å¼·ã•ãŒé«˜ã„å ´åˆã€å¤–å´ã®ç‚¹ã«æ”¾å°„ç·šï¼ˆç”Ÿå‘½ã®èºå‹•ï¼‰
                if (gp > 0.4 && t > 0.6 && i % 5 === 0) {
                    const rayLength = 2 + gp * 4 + regenerationProgress * 3;
                    const rayAngle = Math.atan2(point.y - center, point.x - center);
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${seedOpacityBase * 0.7})`;
                    ctx.lineWidth = 0.3 + gp * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(
                        point.x + rayLength * Math.cos(rayAngle),
                        point.y + rayLength * Math.sin(rayAngle)
                    );
                    ctx.stroke();
                }
            }
            
            // DNAäºŒé‡èºæ—‹ï¼ˆéºä¼æƒ…å ±ï¼‰- Stage 1ã¨åŒã˜ã€ä¸­å¿ƒã«é…ç½®
            const dnaSeedRadius = seedRadius * 0.2;
            const dnaSeedTurns = 1 + gp * 0.8;
            const dnaSeedSegments = 20;
            
            ctx.strokeStyle = `rgba(0, 0, 0, ${seedOpacityBase * 0.8})`;
            ctx.lineWidth = 0.2 + gp * 0.15;
            
            // ç¬¬1èºæ—‹
            ctx.beginPath();
            for (let i = 0; i <= dnaSeedSegments; i++) {
                const t = i / dnaSeedSegments;
                const angle = t * dnaSeedTurns * Math.PI * 2;
                const z = t * 2 - 1; // -1 to 1
                
                const x = center + dnaSeedRadius * Math.cos(angle) * (0.3 + z * z * 0.7);
                const y = center + dnaSeedRadius * z;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // ç¬¬2èºæ—‹ï¼ˆ180åº¦ä½ç›¸ãšã‚Œï¼‰
            ctx.beginPath();
            for (let i = 0; i <= dnaSeedSegments; i++) {
                const t = i / dnaSeedSegments;
                const angle = t * dnaSeedTurns * Math.PI * 2 + Math.PI;
                const z = t * 2 - 1;
                
                const x = center + dnaSeedRadius * Math.cos(angle) * (0.3 + z * z * 0.7);
                const y = center + dnaSeedRadius * z;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
            
            // === å¤–å´ã¸ã®æ–°ã—ã„ç¨®å­ã®æ‹¡æ•£ï¼ˆãƒ•ã‚£ãƒœãƒŠãƒƒãƒé…ç½®ï¼‰===
            if (regenerationProgress > 0 || decompositionProgress > 0.7) {
                const numOuterSeeds = Math.floor(12 + regenerationProgress * 35);
                
                for (let i = 0; i < numOuterSeeds; i++) {
                    const angle = i * goldenAngle;
                    const radius = seedRadius * 1.8 + (i / numOuterSeeds) * (15 + regenerationProgress * 30);
                    
                    const outerSeedX = center + radius * Math.cos(angle);
                    const outerSeedY = center + radius * Math.sin(angle);
                    const outerSeedSize = 0.5 + regenerationProgress * 1.8;
                    
                    const outerSeedOpacity = Math.max(regenerationProgress * 0.6, (decompositionProgress - 0.7) * 1.8);
                    ctx.fillStyle = `rgba(0, 0, 0, ${outerSeedOpacity})`;
                    ctx.beginPath();
                    ctx.arc(outerSeedX, outerSeedY, outerSeedSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å¤§ãã‚ã®ç¨®å­ã«ã¯å›æŠ˜åå­—ï¼ˆStage 1ã®ã‚¨ã‚³ãƒ¼ï¼‰
                    if (outerSeedSize > 1.2 && i % 4 === 0) {
                        const crossSize = outerSeedSize * (1.5 + regenerationProgress);
                        ctx.strokeStyle = `rgba(0, 0, 0, ${outerSeedOpacity * 0.6})`;
                        ctx.lineWidth = 0.2 + regenerationProgress * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(outerSeedX - crossSize, outerSeedY);
                        ctx.lineTo(outerSeedX + crossSize, outerSeedY);
                        ctx.moveTo(outerSeedX, outerSeedY - crossSize);
                        ctx.lineTo(outerSeedX, outerSeedY + crossSize);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
        }
        
        // 9. æœªæ¥ - å¾ªç’°ã®å®‡å®™ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆç¨®å­ã‹ã‚‰éŠ€æ²³ã¸ï¼‰çµ±åˆç‰ˆ
        function drawFuture(ctx, center, gp, on, weight) {
            // ã‚·ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã‚‰åŒã˜çµæœã‚’ä¿è¨¼ï¼‰
            resetRandomForStage(9);
            
            // === ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ç¯„å›²ã‚’è¨­å®š ===
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º280x280ã€ä¸­å¿ƒ140ãªã®ã§ã€å®‰å…¨ç¯„å›²ã¯ä¸­å¿ƒã‹ã‚‰Â±115
            const canvasSize = 280;
            const maxRadius = 115; // ä¸­å¿ƒã‹ã‚‰ã®æœ€å¤§è·é›¢
            
            // === æ™‚é–“ã«ã‚ˆã‚‹ç‰©èªã®å¤‰åŒ– ===
            // weight < 1: Stage 8ã®ç¨®å­ã‹ã‚‰åºƒãŒã‚Šå§‹ã‚ã‚‹ï¼ˆéå»ï¼‰
            // weight = 1: éŠ€æ²³ã¨ã—ã¦å®Œå…¨å±•é–‹ï¼ˆç¾åœ¨ï¼‰
            // weight > 1: æ–°ã—ã„éŠ€æ²³ã®èª•ç”Ÿï¼ˆæœªæ¥ï¼‰
            const expansionProgress = Math.min(1, weight); // 0ã€œ1
            const newBirthProgress = weight > 1 ? (weight - 1) * 1.5 : 0; // 0ã€œ1
            
            // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åŠ‡çš„ã«å¤‰åŒ–ã•ã›ã‚‹
            const gpDynamic = Math.pow(gp, 2); // æŒ‡æ•°é–¢æ•°çš„å¤‰åŒ–
            const scale = 0.3 + gpDynamic * 1.5; // 0.3å€ã€œ1.8å€
            
            const goldenAngle = 137.5 * (Math.PI / 180);
            const phi = (1 + Math.sqrt(5)) / 2;
            
            // éŠ€æ²³ã®è…•ã®æ•°ï¼ˆãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ï¼š1,2,3,5,8ï¼‰
            const fibSequence = [1, 2, 3, 5, 8];
            const galaxyArms = fibSequence[Math.min(4, Math.floor(gpDynamic * 5))];
            
            // === Stage 8ã®ç¨®å­ã‹ã‚‰ã®ã‚¨ã‚³ãƒ¼ï¼ˆä¸­å¿ƒï¼‰ ===
            if (expansionProgress < 0.5) {
                // ç¨®å­ã®phyllotaxisãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ®‹ã‚‹
                const seedEchoPoints = Math.floor(20 + gp * 40 * (1 - expansionProgress * 2));
                
                for (let i = 0; i < seedEchoPoints; i++) {
                    const angle = i * goldenAngle;
                    const radius = Math.sqrt(i) * 3 * (1 - expansionProgress * 2);
                    
                    const x = center + radius * Math.cos(angle);
                    const y = center + radius * Math.sin(angle);
                    
                    ctx.fillStyle = `rgba(0, 0, 0, ${(1 - expansionProgress * 2) * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 0.5 + gp * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = 'black';
            }
            
            // === éŠ€æ²³ã®è…•ï¼ˆå¯¾æ•°èºæ—‹ãƒ»é»„é‡‘æ¯”ï¼‰ ===
            for (let arm = 0; arm < galaxyArms; arm++) {
                const armAngleOffset = (arm / galaxyArms) * Math.PI * 2;
                const spiralTightness = 0.18 + gpDynamic * 0.5; // é»„é‡‘æ¯”ã«è¿‘ã¥ã‘ã‚‹
                const points = Math.floor(60 + gpDynamic * 280 * expansionProgress);
                
                // æ™‚é–“ã§è…•ãŒä¼¸ã³ã‚‹
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.6 + expansionProgress * 0.4})`;
                ctx.lineWidth = 0.4 + gpDynamic * 2.8;
                ctx.beginPath();
                
                for (let i = 0; i <= points; i++) {
                    const t = i / points;
                    const angle = armAngleOffset + t * Math.PI * (5 + gpDynamic * 5);
                    const radius = t * (50 + gpDynamic * 50) * expansionProgress; // 70â†’50ã«å‰Šæ¸›
                    
                    // å¯¾æ•°èºæ—‹ï¼ˆé»„é‡‘æ¯”ï¼‰- åŠå¾„ã‚’åˆ¶é™
                    let r = radius * Math.exp(spiralTightness * (angle - armAngleOffset) / phi);
                    r = Math.min(r, maxRadius * 0.95); // æœ€å¤§åŠå¾„ã‚’åˆ¶é™
                    
                    const noise = perlin.get(
                        Math.cos(angle) * arm * 0.3 + noiseOffset,
                        Math.sin(angle) * arm * 0.3
                    ) * on * (8 + gpDynamic * 10); // ãƒã‚¤ã‚ºã‚‚å‰Šæ¸›
                    
                    const finalR = Math.min(r + noise, maxRadius); // æœ€çµ‚åŠå¾„ã‚’åˆ¶é™
                    const x = center + finalR * Math.cos(angle);
                    const y = center + finalR * Math.sin(angle);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            ctx.strokeStyle = 'black';
            
            // === æ˜Ÿé›²ï¼ˆå¯èƒ½æ€§ã®é›²ï¼‰===
            if (expansionProgress > 0.3) {
                const numNebulae = Math.floor(2 + gpDynamic * 6);
                
                for (let n = 0; n < numNebulae; n++) {
                    const nebulaAngle = (n / numNebulae) * Math.PI * 2 + goldenAngle * n;
                    const nebulaDist = Math.min(40 + seededRandom() * 50 * expansionProgress, maxRadius * 0.7); // åˆ¶é™
                    const nebulaX = center + nebulaDist * Math.cos(nebulaAngle);
                    const nebulaY = center + nebulaDist * Math.sin(nebulaAngle);
                    
                    // æ˜Ÿé›²ã®é›²çŠ¶æ§‹é€ 
                    const cloudPoints = Math.floor(30 + gpDynamic * 80);
                    const nebulaSize = Math.min(15 + gpDynamic * 25, 30); // ã‚µã‚¤ã‚ºåˆ¶é™
                    
                    for (let p = 0; p < cloudPoints; p++) {
                        const cloudAngle = (p / cloudPoints) * Math.PI * 2;
                        const cloudR = nebulaSize * Math.sqrt(seededRandom()) * (0.8 + on * 0.4);
                        const cloudNoise = perlin.get(
                            nebulaX * 0.01 + cloudR * 0.1,
                            nebulaY * 0.01 + p * 0.05 + noiseOffset
                        ) * 8;
                        
                        const px = nebulaX + (cloudR + cloudNoise) * Math.cos(cloudAngle);
                        const py = nebulaY + (cloudR + cloudNoise) * Math.sin(cloudAngle);
                        
                        const dotSize = 0.3 + seededRandom() * (0.5 + gpDynamic * 1.2);
                        ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + seededRandom() * 0.25})`;
                        ctx.beginPath();
                        ctx.arc(px, py, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.fillStyle = 'black';
            }
            
            // === æ˜Ÿã€…ï¼ˆæ–°ã—ã„ç¨®å­ï¼‰- ãƒ•ã‚£ãƒœãƒŠãƒƒãƒé…ç½® ===
            const starDensity = Math.floor(60 + gpDynamic * 550 * expansionProgress); // å¤§å¹…ã«å¢—åŠ 
            
            for (let i = 0; i < starDensity; i++) {
                // ãƒ•ã‚£ãƒœãƒŠãƒƒãƒé…ç½®ã¨è…•ã«æ²¿ã£ãŸé…ç½®ã®æ··åˆ
                const useFibonacci = seededRandom() < 0.35; // 35%ã¯ãƒ•ã‚£ãƒœãƒŠãƒƒãƒ
                
                let x, y;
                
                if (useFibonacci) {
                    // ãƒ•ã‚£ãƒœãƒŠãƒƒãƒé…ç½®ï¼ˆä¸­å¿ƒã‹ã‚‰æ”¾å°„ï¼‰- åŠå¾„ã‚’åˆ¶é™
                    const angle = i * goldenAngle;
                    let radius = Math.sqrt(i) * (6 + gpDynamic * 8) * expansionProgress; // å‰Šæ¸›
                    radius = Math.min(radius, maxRadius * 0.9); // åˆ¶é™
                    const scatter = (seededRandom() - 0.5) * 10 * on; // å‰Šæ¸›
                    
                    const finalR = Math.min(radius + scatter, maxRadius);
                    x = center + finalR * Math.cos(angle);
                    y = center + finalR * Math.sin(angle);
                } else {
                    // éŠ€æ²³ã®è…•ã«æ²¿ã£ãŸé…ç½® - åŠå¾„ã‚’åˆ¶é™
                    const armIndex = i % galaxyArms;
                    const t = (i / starDensity);
                    const angle = (armIndex / galaxyArms) * Math.PI * 2 + t * Math.PI * (5 + gpDynamic * 5);
                    const spiralTightness = 0.18 + gpDynamic * 0.5;
                    const radius = t * (50 + gpDynamic * 50) * expansionProgress; // å‰Šæ¸›
                    let r = radius * Math.exp(spiralTightness * angle / phi);
                    r = Math.min(r, maxRadius * 0.9); // åˆ¶é™
                    
                    const scatter = (seededRandom() - 0.5) * (15 + on * 20); // å‰Šæ¸›
                    const scatterAngle = seededRandom() * Math.PI * 2;
                    
                    const finalR = Math.min(r + scatter, maxRadius);
                    x = center + finalR * Math.cos(angle + scatterAngle);
                    y = center + finalR * Math.sin(angle + scatterAngle);
                }
                
                // æ˜Ÿã®ã‚µã‚¤ã‚ºï¼ˆæ–°ã—ã„ç¨®å­ï¼‰
                const starSize = 0.4 + seededRandom() * (0.6 + gpDynamic * 2.5);
                
                ctx.fillStyle = `rgba(0, 0, 0, ${0.5 + seededRandom() * 0.5})`;
                ctx.beginPath();
                ctx.arc(x, y, starSize, 0, Math.PI * 2);
                ctx.fill();
                
                // æ˜ã‚‹ã„æ˜Ÿï¼ˆå›æŠ˜åå­—ãƒ»Stage 1ã®ã‚¨ã‚³ãƒ¼ï¼‰
                if (starSize > 1.3 && seededRandom() > (1 - gpDynamic * 0.6)) {
                    const crossSize = starSize * (2 + gpDynamic * 1.5);
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.4 + gpDynamic * 0.4})`;
                    ctx.lineWidth = 0.25 + gpDynamic * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(x - crossSize, y);
                    ctx.lineTo(x + crossSize, y);
                    ctx.moveTo(x, y - crossSize);
                    ctx.lineTo(x, y + crossSize);
                    ctx.stroke();
                }
            }
            
            ctx.fillStyle = 'black';
            ctx.strokeStyle = 'black';
            
            // === ä¸­å¿ƒï¼ˆå¤§åœ°ã¨å¹´è¼ªã®è¨˜æ†¶ï¼‰===
            const coreRadius = 5 + gpDynamic * 20;
            
            // å¹´è¼ªã®ã‚ˆã†ãªåŒå¿ƒå††ï¼ˆ100å¹´ã€1000å¹´ã€å„„å¹´ã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
            const coreRings = Math.floor(5 + gpDynamic * 12);
            for (let i = 0; i < coreRings; i++) {
                const t = i / coreRings;
                const r = coreRadius * (1 - t * 0.7);
                
                // æ—©æ/æ™©æã®è¡¨ç¾ï¼ˆStage 4ã®ã‚¨ã‚³ãƒ¼ï¼‰
                const isLatewood = i % 2 === 1;
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.5 + t * 0.3 + (isLatewood ? 0.2 : 0)})`;
                ctx.lineWidth = isLatewood ? 0.6 + gpDynamic * 1.2 : 0.3 + gpDynamic * 0.6;
                
                ctx.beginPath();
                
                // æœ‰æ©Ÿçš„ãªæºã‚‰ã
                const segments = 48;
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const noise = perlin.get(
                        Math.cos(angle) * i * 0.2 + noiseOffset,
                        Math.sin(angle) * i * 0.2
                    ) * on * (1 + gpDynamic * 2);
                    
                    const finalR = r + noise;
                    const px = center + finalR * Math.cos(angle);
                    const py = center + finalR * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // ä¸­å¿ƒæ ¸ï¼ˆç¨®å­ãƒ»å¤§åœ°ãƒ»ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«ï¼‰
            ctx.fillStyle = `rgba(0, 0, 0, ${0.7 + gpDynamic * 0.3})`;
            ctx.beginPath();
            ctx.arc(center, center, 2 + gpDynamic * 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
            
            // === ã‚¨ãƒãƒ«ã‚®ãƒ¼æ”¾å°„ï¼ˆå…‰ãƒ»é¤Šåˆ†ãƒ»ç”Ÿå‘½åŠ›ï¼‰ ===
            const rays = Math.floor(8 + gpDynamic * 24);
            const rayLength = coreRadius * (1.5 + gpDynamic * 2);
            
            for (let i = 0; i < rays; i++) {
                const angle = (i / rays) * Math.PI * 2;
                
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.4 + gpDynamic * 0.4})`;
                ctx.lineWidth = 0.3 + gpDynamic * 1;
                ctx.beginPath();
                
                // æ³¢æ‰“ã¤æ”¾å°„ç·š
                const segments = 8;
                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const currentR = coreRadius + (rayLength - coreRadius) * t;
                    const wave = Math.sin(t * Math.PI * 3) * on * (2 + gpDynamic * 3);
                    const finalR = currentR + wave;
                    
                    const px = center + finalR * Math.cos(angle);
                    const py = center + finalR * Math.sin(angle);
                    
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            
            ctx.strokeStyle = 'black';
            
            // === æ–°ã—ã„éŠ€æ²³ã®èª•ç”Ÿï¼ˆæœªæ¥ã¸ã®äºˆæ„Ÿï¼‰===
            if (newBirthProgress > 0.1) {
                // å¤–ç¸éƒ¨ã«æ–°ã—ã„ç¨®å­ï¼ˆéŠ€æ²³ï¼‰ãŒèŠ½å¹ã
                const newGalaxies = Math.floor(3 + newBirthProgress * 8);
                
                for (let i = 0; i < newGalaxies; i++) {
                    const angle = i * goldenAngle * 2;
                    const distance = Math.min(80 + newBirthProgress * 15, maxRadius * 0.85); // åˆ¶é™
                    const gx = center + distance * Math.cos(angle);
                    const gy = center + distance * Math.sin(angle);
                    
                    // å°ã•ãªèºæ—‹ï¼ˆæ–°ã—ã„å¾ªç’°ã®å§‹ã¾ã‚Šï¼‰
                    const miniSpiral = Math.floor(2 + newBirthProgress * 3);
                    for (let j = 0; j < miniSpiral; j++) {
                        const spiralAngle = (j / miniSpiral) * Math.PI * 2;
                        const spiralR = (3 + newBirthProgress * 8) * (1 + j * 0.3);
                        
                        ctx.strokeStyle = `rgba(0, 0, 0, ${newBirthProgress * 0.5})`;
                        ctx.lineWidth = 0.3 + newBirthProgress * 0.5;
                        ctx.beginPath();
                        
                        const spiralSegments = 15;
                        for (let k = 0; k <= spiralSegments; k++) {
                            const t = k / spiralSegments;
                            const a = spiralAngle + t * Math.PI * 2;
                            const r = spiralR * t;
                            
                            const px = gx + r * Math.cos(a);
                            const py = gy + r * Math.sin(a);
                            
                            if (k === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }
                    
                    // ä¸­å¿ƒç‚¹
                    ctx.fillStyle = `rgba(0, 0, 0, ${newBirthProgress * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(gx, gy, 0.8 + newBirthProgress * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // === ç”Ÿå‘½ã®ã¤ãªãŒã‚Šï¼ˆå…‰ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰===
            if (expansionProgress > 0.5 && gp > 0.3) {
                const numConnections = Math.floor(8 + gpDynamic * 35);
                
                for (let i = 0; i < numConnections; i++) {
                    const angle1 = i * goldenAngle * 1.5;
                    const angle2 = (i + 3) * goldenAngle * 1.5;
                    const dist1 = Math.min(30 + (i / numConnections) * 70 * expansionProgress, maxRadius * 0.8); // åˆ¶é™
                    const dist2 = Math.min(30 + ((i + 3) / numConnections) * 70 * expansionProgress, maxRadius * 0.8); // åˆ¶é™
                    
                    const x1 = center + dist1 * Math.cos(angle1);
                    const y1 = center + dist1 * Math.sin(angle1);
                    const x2 = center + dist2 * Math.cos(angle2);
                    const y2 = center + dist2 * Math.sin(angle2);
                    
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    if (distance < 80) {
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.08 + seededRandom() * 0.12})`;
                        ctx.lineWidth = 0.2 + gpDynamic * 0.5;
                        
                        ctx.beginPath();
                        // ãƒ™ã‚¸ã‚§æ›²ç·šã§æœ‰æ©Ÿçš„ã«
                        const midX = (x1 + x2) / 2 + perlin.get(i * 0.2, noiseOffset) * 15 * on;
                        const midY = (y1 + y2) / 2 + perlin.get(i * 0.2 + 100, noiseOffset) * 15 * on;
                        ctx.moveTo(x1, y1);
                        ctx.quadraticCurveTo(midX, midY, x2, y2);
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === æ–°ã—ã„ç”Ÿå‘½ã®èŠ½å¹ãï¼ˆå°ã•ãªè‹¥æœ¨ã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆï¼‰===
            if (expansionProgress > 0.6 && gp > 0.5) {
                const numSaplings = Math.floor(3 + gpDynamic * 12);
                
                for (let s = 0; s < numSaplings; s++) {
                    const saplingAngle = s * goldenAngle * 2;
                    const saplingDist = Math.min(50 + (s / numSaplings) * 55 * expansionProgress, maxRadius * 0.8); // åˆ¶é™
                    const sx = center + saplingDist * Math.cos(saplingAngle);
                    const sy = center + saplingDist * Math.sin(saplingAngle);
                    
                    const saplingHeight = 5 + gpDynamic * 12;
                    const saplingWidth = 2 + gpDynamic * 5;
                    
                    // å¹¹
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 + gpDynamic * 0.4})`;
                    ctx.lineWidth = 0.4 + gpDynamic * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx, sy - saplingHeight);
                    ctx.stroke();
                    
                    // æï¼ˆ3-5æœ¬ã®è¼ªç”Ÿï¼‰
                    const numBranches = Math.floor(2 + gpDynamic * 3);
                    for (let b = 1; b <= numBranches; b++) {
                        const branchY = sy - (saplingHeight * b) / (numBranches + 1);
                        const branchAngle = (b / numBranches) * Math.PI * 2;
                        const branchLength = saplingWidth * (1 - b / (numBranches + 2));
                        
                        ctx.lineWidth = 0.25 + gpDynamic * 0.4;
                        ctx.beginPath();
                        ctx.moveTo(sx, branchY);
                        ctx.lineTo(sx + branchLength * Math.cos(branchAngle), branchY + branchLength * Math.sin(branchAngle) * 0.5);
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // === å…‰ã®æ³¢ï¼ˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã®å¾ªç’°ï¼‰===
            if (expansionProgress > 0.4) {
                const numWaves = Math.floor(4 + gpDynamic * 10);
                
                for (let w = 0; w < numWaves; w++) {
                    const waveAngle = (w / numWaves) * Math.PI * 2;
                    const waveRadius = Math.min(35 + w * (6 + gpDynamic * 8) * expansionProgress, maxRadius * 0.85); // åˆ¶é™
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.08 + seededRandom() * 0.12})`;
                    ctx.lineWidth = 0.2 + gpDynamic * 0.4;
                    ctx.beginPath();
                    
                    const waveSegments = 48;
                    for (let seg = 0; seg <= waveSegments; seg++) {
                        const segAngle = (seg / waveSegments) * Math.PI * 2;
                        const waveNoise = perlin.get(
                            Math.cos(segAngle) * w * 0.2 + noiseOffset,
                            Math.sin(segAngle) * w * 0.2
                        ) * on * (5 + gpDynamic * 10);
                        
                        const r = waveRadius + waveNoise;
                        const px = center + r * Math.cos(segAngle);
                        const py = center + r * Math.sin(segAngle);
                        
                        if (seg === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«: ãƒŸãƒ‹æ¸¦ï¼ˆgpãŒé«˜ã„ã»ã©å¤šã„ï¼‰- æ—¢å­˜è¦ç´ ã¯æ®‹ã™
            const miniVortexes = Math.floor(gpDynamic * 8); // å°‘ã—å¢—åŠ 
            
            for (let v = 0; v < miniVortexes; v++) {
                const vortexAngle = (v / Math.max(1, miniVortexes)) * Math.PI * 2;
                const vortexDist = Math.min((35 + seededRandom() * 25), maxRadius * 0.6); // åˆ¶é™
                const vx = center + vortexDist * Math.cos(vortexAngle);
                const vy = center + vortexDist * Math.sin(vortexAngle);
                
                const miniSpiral = Math.floor(15 + gpDynamic * 25); // æ¸¦ã®å·»ãæ•°ã‚‚å¤‰åŒ–
                ctx.lineWidth = 0.3 + gpDynamic * 0.6;
                ctx.beginPath();
                
                for (let i = 0; i <= miniSpiral; i++) {
                    const t = i / miniSpiral;
                    const a = t * Math.PI * (3 + gpDynamic * 3); // å›è»¢æ•°ã‚‚å¤‰åŒ–
                    const r = t * (8 + gpDynamic * 12);
                    
                    const x = vx + r * Math.cos(a + vortexAngle);
                    const y = vy + r * Math.sin(a + vortexAngle);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // ãƒŸãƒ‹æ¸¦ã®ä¸­å¿ƒ
                ctx.beginPath();
                ctx.arc(vx, vy, 1 + gpDynamic * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // === å¤šå±¤çš„ãªèºæ—‹ï¼ˆæ§˜ã€…ãªã‚¹ã‚±ãƒ¼ãƒ«ã®å¯èƒ½æ€§ï¼‰===
            if (expansionProgress > 0.5 && gp > 0.4) {
                const numMultiSpirals = Math.floor(2 + gpDynamic * 4);
                
                for (let ms = 0; ms < numMultiSpirals; ms++) {
                    const spiralBaseAngle = (ms / numMultiSpirals) * Math.PI * 2;
                    const spiralPoints = Math.floor(15 + gpDynamic * 40);
                    const spiralTightness = 0.15 + ms * 0.08;
                    
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.12 + gpDynamic * 0.18})`;
                    ctx.lineWidth = 0.25 + gpDynamic * 0.6;
                    ctx.beginPath();
                    
                    for (let sp = 0; sp <= spiralPoints; sp++) {
                        const t = sp / spiralPoints;
                        const angle = spiralBaseAngle + t * Math.PI * (4 + gpDynamic * 3);
                        const radius = t * (40 + gpDynamic * 35) * expansionProgress; // å‰Šæ¸›
                        let r = radius * Math.exp(spiralTightness * angle);
                        r = Math.min(r, maxRadius * 0.9); // åˆ¶é™
                        
                        const spiralNoise = perlin.get(
                            Math.cos(angle) * ms * 0.3 + noiseOffset * 1.5,
                            Math.sin(angle) * ms * 0.3
                        ) * on * 20; // å‰Šæ¸›
                        
                        const finalR = Math.min(r + spiralNoise, maxRadius);
                        const px = center + finalR * Math.cos(angle);
                        const py = center + finalR * Math.sin(angle);
                        
                        if (sp === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // æ˜Ÿé–“ã®ç¹‹ãŒã‚Šï¼ˆonãŒé«˜ã„ã¨è¦‹ãˆã‚‹ï¼‰- å¼·åŒ–ç‰ˆ
            if (on > 0.2) { // é–¾å€¤ã‚’ä¸‹ã’ã¦è¡¨ç¤ºã—ã‚„ã™ã
                const connections = Math.floor(on * gpDynamic * 65); // 0ã€œ65ã«å¢—åŠ 
                ctx.lineWidth = 0.15 + on * 0.4;
                
                for (let i = 0; i < connections; i++) {
                    const angle1 = seededRandom() * Math.PI * 2;
                    const angle2 = seededRandom() * Math.PI * 2;
                    const dist1 = Math.min(20 + seededRandom() * (80 * expansionProgress), maxRadius * 0.85); // åˆ¶é™
                    const dist2 = Math.min(20 + seededRandom() * (80 * expansionProgress), maxRadius * 0.85); // åˆ¶é™
                    
                    const x1 = center + dist1 * Math.cos(angle1);
                    const y1 = center + dist1 * Math.sin(angle1);
                    const x2 = center + dist2 * Math.cos(angle2);
                    const y2 = center + dist2 * Math.sin(angle2);
                    
                    // è¿‘ã„æ˜ŸåŒå£«ã ã‘ç¹‹ã
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    if (distance < 70) { // è·é›¢ã‚’å»¶é•·
                        ctx.strokeStyle = `rgba(0, 0, 0, ${0.08 + on * 0.15})`;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = 'black';
            }
            
            // ãƒªã‚»ãƒƒãƒˆ
            ctx.strokeStyle = 'black';
            ctx.fillStyle = 'black';
        }
        
        function generateAllPatterns() {
            // noiseOffsetã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦æ±ºå®šè«–çš„ã«ç”Ÿæˆ
            // ã“ã‚Œã«ã‚ˆã‚ŠCanvasæç”»ã¨SVGç”Ÿæˆã§åŒã˜noiseOffsetãŒä½¿ã‚ã‚Œã‚‹
            setSeed(42); // å›ºå®šã‚·ãƒ¼ãƒ‰ã§noiseOffsetã‚’ç”Ÿæˆ
            noiseOffset = seededRandom() * 10000;
            
            for (let stage = 1; stage <= 9; stage++) {
                const canvas = document.getElementById(`canvas-${stage}`);
                generatePattern(canvas, stage, growthPower, organicNature, timeFlow);
            }
        }
        
        function regenerateAll() {
            generateAllPatterns();
        }
        
        function downloadImage() {
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = 900;
            outputCanvas.height = 900;
            const outCtx = outputCanvas.getContext('2d');
            
            outCtx.fillStyle = 'white';
            outCtx.fillRect(0, 0, 900, 900);
            
            for (let i = 0; i < 9; i++) {
                const canvas = document.getElementById(`canvas-${i + 1}`);
                const col = i % 3;
                const row = Math.floor(i / 3);
                outCtx.drawImage(canvas, col * 300, row * 300, 300, 300);
            }
            
            outputCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `karamatsu-cycle-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        // ========================================
        // ã‚«ãƒ¼ãƒ‰ç”»åƒç”Ÿæˆé–¢æ•°ï¼ˆç‰©èªã®æƒ…æ™¯ï¼‹é­”æ³•ä»˜ãï¼‰
        // ========================================
        function downloadCardImage() {
            if (!selectedStage) {
                alert('ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const stage = selectedStage;
            const cardWidth = 600;
            const cardHeight = 1200; // å®Œå…¨ãªé­”æ³•èª¬æ˜ã®ãŸã‚é«˜ã•ã‚’å¢—ã‚„ã™
            const padding = 30;
            const imageSize = 360; // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«
            
            // ã‚«ãƒ¼ãƒ‰ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
            const cardCanvas = document.createElement('canvas');
            cardCanvas.width = cardWidth;
            cardCanvas.height = cardHeight;
            const ctx = cardCanvas.getContext('2d');
            
            // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆé«˜ç´šæ„Ÿã®ã‚ã‚‹å’Œç´™é¢¨ï¼‰
            const gradient = ctx.createLinearGradient(0, 0, 0, cardHeight);
            gradient.addColorStop(0, '#f8f6f0');
            gradient.addColorStop(0.5, '#f5f3ed');
            gradient.addColorStop(1, '#ebe8e0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, cardWidth, cardHeight);
            
            // æ ç·šï¼ˆå¢¨è‰²ï¼‰
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.strokeRect(15, 15, cardWidth - 30, cardHeight - 30);
            
            // å†…å´ã®ç´°ã„æ ç·š
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.strokeRect(25, 25, cardWidth - 50, cardHeight - 50);
            
            // å›³æŸ„ã‚’é…ç½®ï¼ˆä¸­å¤®ä¸Šéƒ¨ï¼‰
            const sourceCanvas = document.getElementById(`canvas-${stage}`);
            const imageX = (cardWidth - imageSize) / 2;
            const imageY = padding + 15;
            
            // å›³æŸ„ã®æ 
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.strokeRect(imageX - 5, imageY - 5, imageSize + 10, imageSize + 10);
            
            // å›³æŸ„ã‚’æç”»
            ctx.drawImage(sourceCanvas, imageX, imageY, imageSize, imageSize);
            
            // ã‚¿ã‚¤ãƒˆãƒ«
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 26px "Hiragino Mincho ProN", "Yu Mincho", serif';
            ctx.textAlign = 'center';
            ctx.fillText(stageNames[stage], cardWidth / 2, imageY + imageSize + 40);
            
            // ã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‹±èªï¼‰
            const englishTitles = [
                '', 'Seed', 'Sprout', 'Sapling', 'Growth', 
                'Timber', 'Processing', 'Scrap', 'Regeneration', 'Future'
            ];
            ctx.font = '14px "Helvetica Neue", Arial, sans-serif';
            ctx.fillStyle = '#7f8c8d';
            ctx.fillText(`Stage ${stage}: ${englishTitles[stage]}`, cardWidth / 2, imageY + imageSize + 60);
            
            // === ç‰©èªã®æƒ…æ™¯ ===
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding + 20, imageY + imageSize + 78);
            ctx.lineTo(cardWidth - padding - 20, imageY + imageSize + 78);
            ctx.stroke();
            
            // ç‰©èªã®æƒ…æ™¯ãƒ©ãƒ™ãƒ«
            let textY = imageY + imageSize + 98;
            ctx.fillStyle = '#5d6d7e';
            ctx.font = 'bold 12px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('ã€ç‰©èªã®æƒ…æ™¯ã€‘', padding + 10, textY);
            
            // ç‰©èªã®æƒ…æ™¯ãƒ†ã‚­ã‚¹ãƒˆï¼ˆè‡ªå‹•æ”¹è¡Œï¼‰
            textY += 20;
            ctx.fillStyle = '#34495e';
            ctx.font = '13px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
            
            const scene = stageScenes[stage];
            const maxWidth = cardWidth - padding * 2 - 20;
            const lineHeight = 20;
            
            // ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã«åˆ†å‰²ï¼ˆç‰©èªã®æƒ…æ™¯ï¼‰
            let line = '';
            for (let i = 0; i < scene.length; i++) {
                const testLine = line + scene[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line !== '') {
                    ctx.fillText(line, padding + 10, textY);
                    line = scene[i];
                    textY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, padding + 10, textY);
            
            // === ä½¿ã‚ã‚Œã¦ã„ã‚‹é­”æ³• ===
            textY += lineHeight + 15;
            ctx.strokeStyle = '#d4af37'; // é‡‘è‰²ã®åŒºåˆ‡ã‚Šç·š
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(padding + 20, textY);
            ctx.lineTo(cardWidth - padding - 20, textY);
            ctx.stroke();
            
            // é­”æ³•ãƒ©ãƒ™ãƒ«
            textY += 20;
            ctx.fillStyle = '#8b6914';
            ctx.font = 'bold 12px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('ğŸ”® ä½¿ã‚ã‚Œã¦ã„ã‚‹é­”æ³•', padding + 10, textY);
            
            // é­”æ³•ã‚¿ã‚°
            textY += 18;
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 12px "Helvetica Neue", Arial, sans-serif';
            ctx.fillText(stageMagicTags[stage], padding + 10, textY);
            
            // é­”æ³•ã®èª¬æ˜
            textY += 22;
            ctx.fillStyle = '#5d6d7e';
            ctx.font = '12px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
            
            const magicDesc = stageMagicDesc[stage];
            line = '';
            for (let i = 0; i < magicDesc.length; i++) {
                const testLine = line + magicDesc[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line !== '') {
                    ctx.fillText(line, padding + 10, textY);
                    line = magicDesc[i];
                    textY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, padding + 10, textY);
            
            // === ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æƒ…å ± ===
            textY += lineHeight + 10;
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding + 20, textY);
            ctx.lineTo(cardWidth - padding - 20, textY);
            ctx.stroke();
            
            textY += 16;
            ctx.font = '11px "Helvetica Neue", Arial, sans-serif';
            ctx.fillStyle = '#95a5a6';
            ctx.textAlign = 'center';
            ctx.fillText(`Growth: ${growthPower}%  |  Organic: ${organicNature}%  |  Time: ${timeFlow}`, cardWidth / 2, textY);
            
            // === ãƒ•ãƒƒã‚¿ãƒ¼ï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«ç¶šãä½ç½®ï¼‰ ===
            textY += 30;
            ctx.font = '11px "Helvetica Neue", Arial, sans-serif';
            ctx.fillStyle = '#bdc3c7';
            ctx.fillText('æ£®ãŒè‚²ã‚€ã€ã„ã®ã¡ã®å¾ªç’° â€” ã„ã‚ã¯ã™ãŒç”Ÿã¾ã‚Œã‚‹å²©æ‰‹ã®æ£®', cardWidth / 2, textY);
            
            textY += 14;
            ctx.font = '10px "Helvetica Neue", Arial, sans-serif';
            ctx.fillText('Karamatsu Lifecycle Interactive Designer', cardWidth / 2, textY);
            
            textY += 14;
            ctx.font = '10px "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
            ctx.fillStyle = '#95a5a6';
            ctx.fillText('Â© ima Design Labï½œæ¾æ£®æœ¨å·¥æ‰€', cardWidth / 2, textY);
            
            // ã‚«ãƒ¼ãƒ‰ã®å®Ÿéš›ã®é«˜ã•ã‚’è¨ˆç®—ã—ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ãƒªã‚µã‚¤ã‚º
            const actualCardHeight = textY + 40; // ä¸‹ä½™ç™½ï¼ˆ1è¡Œåˆ†è¿½åŠ ï¼‰
            
            // æ–°ã—ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆã—ã¦é©åˆ‡ãªã‚µã‚¤ã‚ºã§å†æç”»
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = cardWidth;
            finalCanvas.height = actualCardHeight;
            const finalCtx = finalCanvas.getContext('2d');
            
            // èƒŒæ™¯ã‚’å†æç”»
            const finalGradient = finalCtx.createLinearGradient(0, 0, 0, actualCardHeight);
            finalGradient.addColorStop(0, '#f8f6f0');
            finalGradient.addColorStop(0.5, '#f5f3ed');
            finalGradient.addColorStop(1, '#ebe8e0');
            finalCtx.fillStyle = finalGradient;
            finalCtx.fillRect(0, 0, cardWidth, actualCardHeight);
            
            // å…ƒã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å†…å®¹ã‚’ã‚³ãƒ”ãƒ¼
            finalCtx.drawImage(cardCanvas, 0, 0);
            
            // æ ç·šã‚’å†æç”»ï¼ˆæ–°ã—ã„é«˜ã•ã«åˆã‚ã›ã¦ï¼‰
            finalCtx.strokeStyle = '#2c3e50';
            finalCtx.lineWidth = 3;
            finalCtx.strokeRect(15, 15, cardWidth - 30, actualCardHeight - 30);
            finalCtx.strokeStyle = '#7f8c8d';
            finalCtx.lineWidth = 1;
            finalCtx.strokeRect(25, 25, cardWidth - 50, actualCardHeight - 50);
            
            // æœ€çµ‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½¿ç”¨
            const outputCanvas = finalCanvas;
            
            // ç”»åƒã¨ã—ã¦ä¿å­˜ï¼ˆå‹•çš„ã‚µã‚¤ã‚ºã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½¿ç”¨ï¼‰
            outputCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `karamatsu_stage${stage}_card.png`;
                
                // ã‚¹ãƒãƒ›å¯¾å¿œ: ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // iOSã®å ´åˆã¯æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ãï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ããªã„å ´åˆã®ä»£æ›¿ï¼‰
                if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                    // Blobã‚’æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§è¡¨ç¤º
                    window.open(url, '_blank');
                    alert('ğŸ“± ç”»åƒãŒæ–°ã—ã„ã‚¿ãƒ–ã§é–‹ãã¾ã—ãŸã€‚\né•·æŠ¼ã—ã—ã¦ã€Œç”»åƒã‚’ä¿å­˜ã€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                } else {
                    URL.revokeObjectURL(url);
                }
            }, 'image/png');
        }
        
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateParamDisplay() {
            document.getElementById('param-gp-display').textContent = growthPower;
            document.getElementById('param-on-display').textContent = organicNature;
            document.getElementById('param-tf-display').textContent = timeFlow;
        }
        
        // ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠæ©Ÿèƒ½
        function selectStage(stageNumber) {
            selectedStage = stageNumber;
            
            // å…¨ã¦ã®canvasã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤
            for (let i = 1; i <= 9; i++) {
                const canvas = document.getElementById(`canvas-${i}`);
                const cell = canvas.parentElement;
                cell.classList.remove('selected');
                cell.style.border = '3px solid #34495e'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™
            }
            
            // é¸æŠã•ã‚ŒãŸcanvasã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆæ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ï¼‰
            const selectedCanvas = document.getElementById(`canvas-${stageNumber}`);
            const selectedCell = selectedCanvas.parentElement;
            selectedCell.classList.add('selected');
            
            // é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸åã‚’æ›´æ–°
            document.getElementById('selected-stage-name').textContent = stageNames[stageNumber];
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            document.getElementById('svg-download-btn').disabled = false;
            
            // æ¯”è¼ƒç”¨ã«ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
            saveForCompare();
        }
        
        // Canvasè¦ç´ ã«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
        function setupStageSelection() {
            for (let stage = 1; stage <= 9; stage++) {
                const canvas = document.getElementById(`canvas-${stage}`);
                canvas.style.cursor = 'pointer';
                canvas.addEventListener('click', () => selectStage(stage));
            }
        }
        
        // SVGç”Ÿæˆé–¢æ•°ï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‘ã‚¹ç”Ÿæˆ - canvas2svgä½¿ç”¨ï¼‰
        function generateSVG(stageNumber) {
            try {
                // canvas2svgãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (typeof C2S === 'undefined') {
                    throw new Error('canvas2svg ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                }
                
                // â˜…é‡è¦: Canvasæç”»ã¨åŒã˜noiseOffsetã‚’å†ç¾
                setSeed(42);
                noiseOffset = seededRandom() * 10000;
                
                // 39mmÃ—39mmï¼ˆC3é¢å–ã‚Šå¾Œã®ã‚µã‚¤ã‚ºï¼‰
                const svgSize = 39; // mm
                const pixelSize = 400; // ãƒ”ã‚¯ã‚»ãƒ«ï¼ˆé«˜è§£åƒåº¦ï¼‰
                
                // canvas2svgã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‘ã‚¹ç”Ÿæˆï¼‰
                const ctx = new C2S(pixelSize, pixelSize);
                
                // èƒŒæ™¯ã¯é€æ˜ï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼åŠ å·¥ç”¨ï¼‰
                
                // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æç”»
                // â˜…é‡è¦: generatePattern ã¨åŒã˜è¨ˆç®—å¼ã‚’ä½¿ç”¨
                const center = pixelSize / 2;
                const gpNorm = growthPower / 100;
                const onNorm = organicNature / 100;
                const tfNorm = timeFlow / 100;
                
                // Canvasæç”»ã¨åŒã˜åŠ¹æœè¨ˆç®—
                const gpEffect = Math.pow(gpNorm, 1.3);
                const onEffect = Math.pow(onNorm, 0.8);
                const weight = 1 + (tfNorm * (stageNumber - 5) / 3);
                
                // é¸æŠã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æç”»ï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‘ã‚¹ã¨ã—ã¦ï¼‰
                switch(stageNumber) {
                    case 1: drawSeed(ctx, center, gpEffect, onEffect, weight); break;
                    case 2: drawSprout(ctx, center, gpEffect, onEffect, weight); break;
                    case 3: drawSapling(ctx, center, gpEffect, onEffect, weight); break;
                    case 4: drawGrowth(ctx, center, gpEffect, onEffect, weight); break;
                    case 5: drawTimber(ctx, center, gpEffect, onEffect, weight); break;
                    case 6: drawProcessing(ctx, center, gpEffect, onEffect, weight); break;
                    case 7: drawScrap(ctx, center, gpEffect, onEffect, weight); break;
                    case 8: drawRegeneration(ctx, center, gpEffect, onEffect, weight); break;
                    case 9: drawFuture(ctx, center, gpEffect, onEffect, weight); break;
                }
                
                // SVGæ–‡å­—åˆ—ã‚’å–å¾—ï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‘ã‚¹ï¼‰
                let svgString = ctx.getSerializedSvg();
                
                // ã‚¤ãƒ©ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼äº’æ›ã®SVGã«ä¿®æ­£
                // 1. æ—¢å­˜ã®svgã‚¿ã‚°ã‚’ç½®ãæ›ãˆ
                svgString = svgString.replace(
                    /<svg[^>]*>/,
                    `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${svgSize}mm" height="${svgSize}mm" viewBox="0 0 ${pixelSize} ${pixelSize}">`
                );
                
                // 2. paint-orderå±æ€§ã‚’å‰Šé™¤ï¼ˆã‚¤ãƒ©ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼éå¯¾å¿œï¼‰
                svgString = svgString.replace(/\s*paint-order="[^"]*"/g, '');
                
                // 3. XMLå®£è¨€ã‚’è¿½åŠ 
                svgString = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n` + svgString;
                
                return svgString;
            } catch (error) {
                console.error('SVGç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                alert(`âŒ SVGç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}\n\ncanvas2svgãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã‚ã¦ã„ã¾ã›ã‚“ã€‚\nãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚`);
                return null;
            }
        }
        
        // SVGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–¢æ•°
        function downloadSVG() {
            try {
                if (!selectedStage) {
                    alert('ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é¸æŠã—ã¦ãã ã•ã„');
                    return;
                }
                
                console.log('SVGç”Ÿæˆé–‹å§‹...', { stage: selectedStage, gp: growthPower, on: organicNature, tf: timeFlow });
                
                // SVGã‚’ç”Ÿæˆ
                const svgString = generateSVG(selectedStage);
                
                if (!svgString) {
                    throw new Error('SVGç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                console.log('SVGç”ŸæˆæˆåŠŸ:', svgString.substring(0, 200) + '...');
                
                // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                const filename = `karamatsu_stage${selectedStage}_gp${growthPower}_on${organicNature}_tf${timeFlow}.svg`;
                
                // Blobã‚’ä½œæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†:', filename);
                
                // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                alert(`âœ… SVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼\n\nãƒ•ã‚¡ã‚¤ãƒ«å: ${filename}\n\næ¬¡ã¯ã€ŒGoogle Formsã‚’é–‹ãã€ãƒœã‚¿ãƒ³ã‹ã‚‰æå‡ºã—ã¦ãã ã•ã„ã€‚`);
            } catch (error) {
                console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                alert(`âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}\n\nãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
            }
        }
        
        // Google Formsã‚’é–‹ãé–¢æ•°
        function openGoogleForms() {
            // ã‚¹ãƒ†ãƒ¼ã‚¸ãŒé¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯è­¦å‘Š
            if (!selectedStage) {
                alert('âš ï¸ ã¾ãšã‚¹ãƒ†ãƒ¼ã‚¸ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼\n\n9ã¤ã®å›³æŸ„ã‹ã‚‰1ã¤ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸ã‚“ã§ãã ã•ã„ã€‚');
                return;
            }
            
            // Google Forms ã®ãƒ™ãƒ¼ã‚¹URL
            const baseURL = 'https://docs.google.com/forms/d/e/1FAIpQLSculJGoaf-RFp6xwAu9f0uO5ZA-iI2UnG5Vh2TJ_4erQs0e5A/viewform';
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸åï¼ˆGoogle Formsã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã«åˆã‚ã›ã‚‹ï¼‰
            const stageName = stageNames[selectedStage];
            
            // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
            const params = new URLSearchParams({
                'usp': 'pp_url',
                'entry.1770126510': stageName,           // ã‚¹ãƒ†ãƒ¼ã‚¸ç•ªå·
                'entry.494646067': growthPower,          // æˆé•·ã®åŠ›å¼·ã•
                'entry.268095774': organicNature,        // æœ‰æ©Ÿçš„ãªè‡ªç„¶æ€§
                'entry.939822168': timeFlow              // æ™‚é–“ã®æµã‚Œ
            });
            
            // å®Œå…¨ãªURLã‚’ç”Ÿæˆ
            const formsURL = `${baseURL}?${params.toString()}`;
            
            // æ–°ã—ã„ã‚¿ãƒ–ã§Formsã‚’é–‹ã
            window.open(formsURL, '_blank');
        }
        
        // ========================================
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: ãƒ‡ãƒã‚¦ãƒ³ã‚¹ & requestAnimationFrame
        // ========================================
        
        let renderTimeout = null;
        let isRendering = false;
        
        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ãã®æç”»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼
        function scheduleRender() {
            // æ—¢å­˜ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            
            // 50mså¾Œã«æç”»ã‚’å®Ÿè¡Œï¼ˆé€£ç¶šå…¥åŠ›ä¸­ã¯å»¶æœŸï¼‰
            renderTimeout = setTimeout(() => {
                if (isRendering) return;
                
                isRendering = true;
                requestAnimationFrame(() => {
                    try {
                        generateAllPatterns();
                    } catch (error) {
                        console.error('æç”»ã‚¨ãƒ©ãƒ¼:', error);
                    } finally {
                        isRendering = false;
                        renderTimeout = null;
                    }
                });
            }, 50);
        }
        
        // å³æ™‚æç”»ï¼ˆå€¤è¡¨ç¤ºã®ã¿å³åº§ã«æ›´æ–°ã€æç”»ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        function updateSliderValue(sliderId, valueId, value, suffix = '') {
            document.getElementById(valueId).textContent = value + suffix;
            updateParamDisplay();
            scheduleRender();
        }
        
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å¤‰æ›´ã‚’ç›£è¦–ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
        document.getElementById('growth-power').addEventListener('input', (e) => {
            growthPower = parseInt(e.target.value);
            updateSliderValue('growth-power', 'growth-value', growthPower, '%');
        });
        
        document.getElementById('organic-nature').addEventListener('input', (e) => {
            organicNature = parseInt(e.target.value);
            updateSliderValue('organic-nature', 'organic-value', organicNature, '%');
        });
        
        document.getElementById('time-flow').addEventListener('input', (e) => {
            timeFlow = parseInt(e.target.value);
            updateSliderValue('time-flow', 'time-value', timeFlow, '');
        });
        
        // åˆæœŸåŒ–
        window.addEventListener('load', () => {
            generateAllPatterns();
            setupStageSelection();
            updateParamDisplay();
        });
    </script>
</body>
</html>